[
  {
    "Old Family #": 1,
    "Family Name": "Sorting",
    "Variation": "Sorting",
    "Alias": "",
    "Parents": "",
    "Children": "Comparison Sorting; Non-Comparison Sorting;",
    "Problem Description": "A sorting algorithm is an algorithm that puts elements of a list in a certain order",
    "Description Reference": "https://www.researchgate.net/profile/Adolf-Fenyi-2/publication/346468901_Comparative_Analysis_of_Comparison_and_Non_Comparison_based_Sorting_Algorithms/links/62d80a6c492b5a42c7c3715c/Comparative-Analysis-of-Comparison-and-Non-Comparison-based-Sorting-Algorithms.pdf",
    "Parameters": "$n$: size of list",
    "Parameter for graphs": "n",
    "Input Size": "n",
    "Output Size": "n",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 1,
    "Family Name": "Sorting",
    "Variation": "Comparison Sorting",
    "Alias": "",
    "Parents": "Sorting",
    "Children": "",
    "Problem Description": "A sorting algorithm is an algorithm that puts elements of a list in a certain order, using comparisons between elements.",
    "Description Reference": "https://www.researchgate.net/profile/Adolf-Fenyi-2/publication/346468901_Comparative_Analysis_of_Comparison_and_Non_Comparison_based_Sorting_Algorithms/links/62d80a6c492b5a42c7c3715c/Comparative-Analysis-of-Comparison-and-Non-Comparison-based-Sorting-Algorithms.pdf",
    "Parameters": "$n$: size of list",
    "Parameter for graphs": "n",
    "Input Size": "n",
    "Output Size": "n",
    "Best Known Upper Bound": "O(n*logn)",
    "Upper Bound Reference": "CLRS",
    "Best Known Lower Bound": "Omega(n*logn)",
    "Lower Bound Reference": "CLRS",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 1,
    "Family Name": "Sorting",
    "Variation": "Non-Comparison Sorting",
    "Alias": "",
    "Parents": "Sorting",
    "Children": "Integer Sorting",
    "Problem Description": "A sorting algorithm is an algorithm that puts elements of a list in a certain order, not using comparisons between elements (so elements are typically integers or real numbers).",
    "Description Reference": "https://www.researchgate.net/profile/Adolf-Fenyi-2/publication/346468901_Comparative_Analysis_of_Comparison_and_Non_Comparison_based_Sorting_Algorithms/links/62d80a6c492b5a42c7c3715c/Comparative-Analysis-of-Comparison-and-Non-Comparison-based-Sorting-Algorithms.pdf",
    "Parameters": "$n$: size of list",
    "Parameter for graphs": "n",
    "Input Size": "n",
    "Output Size": "n",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 1,
    "Family Name": "Sorting",
    "Variation": "Integer Sorting",
    "Alias": "",
    "Parents": "Non-Comparison Sorting",
    "Children": "",
    "Problem Description": "A sorting algorithm is an algorithm that puts elements of a list in a certain order, not using comparisons between elements, elements are specifically integers.",
    "Description Reference": "",
    "Parameters": "$n$: size of list",
    "Parameter for graphs": "n",
    "Input Size": "n",
    "Output Size": "n",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 2,
    "Family Name": "kth Order Statistic",
    "Variation": "kth Order Statistic",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "An algorithm seeks to find the $k^{th}$ order statistic of a statistical sample, or the $k^{th}$-smallest value in a list or array.",
    "Description Reference": "https://dl.acm.org/citation.cfm?doid=366622.366647",
    "Parameters": "$n$: size of list",
    "Parameter for graphs": "n",
    "Input Size": "n",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "https://11011110.github.io/blog/2007/10/09/blum-style-analysis-of.html",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 3,
    "Family Name": "Matrix Chain Multiplication",
    "Variation": "Matrix Chain Ordering Problem",
    "Alias": "MCOP",
    "Parents": "",
    "Children": "Approximate MCOP;",
    "Problem Description": "Matrix chain multiplication (or Matrix Chain Ordering Problem; MCOP) is an optimization problem. Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/359545.359556",
    "Parameters": "$n$: number of matrices",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "$O(n \\log n)$",
    "Upper Bound Reference": "https://citeseerx.ist.psu.edu/viewdoc/citations?doi=10.1.1.695.2923",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 3,
    "Family Name": "Matrix Chain Multiplication",
    "Variation": "Approximate MCOP",
    "Alias": "",
    "Parents": "Matrix Chain Ordering Problem",
    "Children": "",
    "Problem Description": "Matrix chain multiplication (or Matrix Chain Ordering Problem; MCOP) is an optimization problem. Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices. In the approximation problem, the matrix multiplication carried out with the output result will use a number of operations that has some sort of upper bound based on the optimal solution.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/359545.359556",
    "Parameters": "$n$: number of matrices",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "$O(\\log \\log n)$",
    "Upper Bound Reference": "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.218.8168&rep=rep1&type=pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 3,
    "Family Name": "Matrix Chain Multiplication",
    "Variation": "Matrix Chain Scheduling Problem",
    "Alias": "MCSP",
    "Parents": "",
    "Children": "Approximate MCSP;",
    "Problem Description": "The Matrix Chain Scheduling Problem (or MCSP) is an optimization problem\f where the goal is to find the product sequence for evaluating a chain of matrix products and the processor schedule for the sequence such that the evaluation time is minimized on a parallel system.",
    "Description Reference": "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.222&rep=rep1&type=pdf",
    "Parameters": "$P$: number of processors\n$n$: number of matrices",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "$O(\\log^3 n)$",
    "Upper Bound Reference": "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.54.9426&rep=rep1&type=pdf",
    "Best Known Lower Bound": "NP-hard",
    "Lower Bound Reference": "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.222&rep=rep1&type=pdf",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 3,
    "Family Name": "Matrix Chain Multiplication",
    "Variation": "Approximate MCSP",
    "Alias": "",
    "Parents": "Matrix Chain Scheduling Problem",
    "Children": "",
    "Problem Description": "The Matrix Chain Scheduling Problem (or MCSP) is an optimization problem\f where the goal is to find the product sequence for evaluating a chain of matrix products and the processor schedule for the sequence such that the evaluation time is minimized on a parallel system. In the approximation problem, the matrix multiplication carried out with the output result will use a number of operations that has some sort of upper bound based on the optimal solution.",
    "Description Reference": "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.222&rep=rep1&type=pdf",
    "Parameters": "$P$: number of processors\n$n$: number of matrices",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "$O(n^2)$",
    "Upper Bound Reference": "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.222&rep=rep1&type=pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 4,
    "Family Name": "Longest Common Subsequence",
    "Variation": "Longest Common Subsequence",
    "Alias": "LCS",
    "Parents": "",
    "Children": "Longest Common Substring with don't cares;",
    "Problem Description": "The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences (often just two sequences).",
    "Description Reference": "https://cse.hkust.edu.hk/mjg_lib/bibs/DPSu/DPSu.Files/HuSz77.pdf",
    "Parameters": "$n$: length of the longer input string\n$m$: length of the shorter input string\n$r$: length of the LCS\n$s$: size of the alphabet\n$p$: the number of dominant matches (AKA number of minimal candidates), i.e. the total number of ordered pairs of positions at which the two sequences match",
    "Parameter for graphs": "m+n",
    "Input Size": "m+n",
    "Output Size": "O(min(m, n))",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "Omega(n^2)",
    "Lower Bound Reference": "Reduction from SETH\n\nhttps://link.springer.com/chapter/10.1007/978-3-662-43948-7_4",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 4,
    "Family Name": "Longest Common Subsequence",
    "Variation": "Length of Longest Common Subsequence",
    "Alias": "LLCS",
    "Parents": "",
    "Children": "",
    "Problem Description": "find only the length of the LCS",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 4,
    "Family Name": "Longest Common Subsequence",
    "Variation": "Sequential Substring Constrained Longest Common Subsequence",
    "Alias": "SSCLCS",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 4,
    "Family Name": "Longest Common Subsequence",
    "Variation": "Multiple Longest Common Subsequence",
    "Alias": "MLCS",
    "Parents": "",
    "Children": "",
    "Problem Description": "LCS of multiple strings",
    "Description Reference": "https://unbscholar.dspace.lib.unb.ca/server/api/core/bitstreams/0979d487-ab0a-4557-94ef-7e35be0c7b24/content",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 4,
    "Family Name": "Longest Common Subsequence",
    "Variation": "All-substrings LCS",
    "Alias": "ALCS",
    "Parents": "",
    "Children": "",
    "Problem Description": "aka string-substring LCS (SS-LCS)\ncomputes the legths of the LCSs of string a with all the substrings of string b",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1213150",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 4,
    "Family Name": "Longest Common Subsequence",
    "Variation": "Longest Common Substring with don't cares",
    "Alias": "",
    "Parents": "Longest Common Subsequence",
    "Children": "",
    "Problem Description": "Find the length of the longest common substring of two strings S and T, where S is a binary string and T is is a binary string and additional * characters that can match either 0 or 1.",
    "Description Reference": "https://link.springer.com/chapter/10.1007/978-3-662-43948-7_4",
    "Parameters": "$n$: length of the longer input string\n$m$: length of the shorter input string\n$r$: length of the LCS\n$s$: size of the alphabet\n$p$: the number of dominant matches (AKA number of minimal candidates), i.e. the total number of ordered pairs of positions at which the two sequences match",
    "Parameter for graphs": "m+n",
    "Input Size": "m+n",
    "Output Size": "O(min(m, n))",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "Omega(n^2)",
    "Lower Bound Reference": "Reduction from SETH\n\nhttps://link.springer.com/chapter/10.1007/978-3-662-43948-7_4",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 5,
    "Family Name": "Maximum Flow",
    "Variation": "st-Maximum Flow",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Find the maximum flow from $s$ to $t$",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/3212510",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge capacity",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(1) for value, O(ElogU) for network",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 5,
    "Family Name": "Maximum Flow",
    "Variation": "Integer Maximum Flow",
    "Alias": "",
    "Parents": "Non-Integer Maximum Flow",
    "Children": "Unweighted Maximum Flow;",
    "Problem Description": "Maximum flow problems involve finding a feasible flow through a flow network that is maximum. In this variant, the capacities must be integers.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/3212510",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge capacity",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(1) for value, O(ElogU) for network",
    "Best Known Upper Bound": "O(min(VE, E^(1+o(1))*log(U)))",
    "Upper Bound Reference": "https://arxiv.org/abs/2203.00671, \nhttps://dl.acm.org/doi/10.1145/2488608.2488705",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 5,
    "Family Name": "Maximum Flow",
    "Variation": "Unweighted Maximum Flow",
    "Alias": "",
    "Parents": "Integer Maximum Flow",
    "Children": "",
    "Problem Description": "Maximum flow problems involve finding a feasible flow through a flow network that is maximum. In this variant, all edges have unit weight.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/3212510",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "O(E)",
    "Output Size": "O(1) for value, O(E) for network",
    "Best Known Upper Bound": "O(E^(1+o(1)))",
    "Upper Bound Reference": "https://arxiv.org/abs/2203.00671",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 5,
    "Family Name": "Maximum Flow",
    "Variation": "Non-integer Maximum Flow",
    "Alias": "",
    "Parents": "",
    "Children": "Integer Maximum Flow;",
    "Problem Description": "Maximum flow problems involve finding a feasible flow through a flow network that is maximum. In this variant, the capacities may be non-integers.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/3212510",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge capacity",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(1) for value, O(ElogU) for network",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 5,
    "Family Name": "Maximum Flow",
    "Variation": "Minimum-Cost Flow",
    "Alias": "MCF",
    "Parents": "",
    "Children": "",
    "Problem Description": "Maximum flow problems involve finding a feasible flow through a flow network that is maximum. In this variant, each edge is given a cost coefficient, and we wish to minimize total cost while reaching a threshold flow.",
    "Description Reference": "https://www.tandfonline.com/doi/pdf/10.1080/10556788.2014.895828",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge capacity\n$d$: minimum required flow",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(1) for value, O(ElogU) for network",
    "Best Known Upper Bound": "O(E^(1+o(1))*log(U))",
    "Upper Bound Reference": "https://arxiv.org/abs/2203.00671",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 5,
    "Family Name": "Maximum Flow",
    "Variation": "All-Pairs Maximum Flow",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Find the maximum flow between all pairs of nodes",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/3212510",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 5,
    "Family Name": "Maximum Flow",
    "Variation": "Maximum Local Edge Connectivity",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Find the pair of nodes with the maximum number of edge-disjoint paths between them",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/3212510",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "reduction from SETH\n\nhttps://dl.acm.org/doi/abs/10.1145/3212510",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 6,
    "Family Name": "Matrix Product",
    "Variation": "Matrix Multiplication",
    "Alias": "",
    "Parents": "",
    "Children": "Boolean Matrix Multiplication; Matrix Product Verification;",
    "Problem Description": "Matrix Multiplication or Matrix Product is a binary operation that produces a matrix from two matrices with entries in a field; or; more generally; in a ring or even a semiring.",
    "Description Reference": "https://era.ed.ac.uk/bitstream/handle/1842/4734/Stothers2010.pdf",
    "Parameters": "$n$: dimension of square matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n^2)",
    "Best Known Upper Bound": "O(n^2.37285956)",
    "Upper Bound Reference": "https://arxiv.org/pdf/2010.05846.pdf",
    "Best Known Lower Bound": "Omega(n^2)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 6,
    "Family Name": "Matrix Product",
    "Variation": "Boolean Matrix Multiplication",
    "Alias": "BMM; and-or Matrix Product",
    "Parents": "Matrix Multiplication",
    "Children": "Boolean Matrix Multiplication (Combinatorial);",
    "Problem Description": "Matrix multiplication of two boolean matrices (i.e. where all entries are in $F_2$ and addition is mod 2)",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4569672",
    "Parameters": "$n$: dimension of square matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n^2)",
    "Best Known Upper Bound": "O(n^2.37285956)",
    "Upper Bound Reference": "https://arxiv.org/pdf/2010.05846.pdf",
    "Best Known Lower Bound": "Omega(n^2)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 6,
    "Family Name": "Matrix Product",
    "Variation": "Boolean Matrix Multiplication (Combinatorial)",
    "Alias": "BMM (Combinatorial)",
    "Parents": "Boolean Matrix Multiplication",
    "Children": "",
    "Problem Description": "Matrix multiplication of two boolean matrices (i.e. where all entries are in $F_2$ and addition is mod 2). Here, only \"combinatorial\" algorithms are considered.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: dimension of square matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n^2)",
    "Best Known Upper Bound": "O(n^3*poly(log log n)/log^4 n)",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/S0890540118300099",
    "Best Known Lower Bound": "$\\Omega(n^{3-\\epsilon})$ for any $\\epsilon > 0$ for combinatorial algorithms",
    "Lower Bound Reference": "BMM Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 6,
    "Family Name": "Matrix Product",
    "Variation": "Matrix Product Verification",
    "Alias": "",
    "Parents": "Matrix Multiplication",
    "Children": "",
    "Problem Description": "Given three matrices $A, B, C$, verify that $AB = C$, i.e. that $C$ is the matrix product of $A$ and $B$",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: dimension of square matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 6,
    "Family Name": "Matrix Product",
    "Variation": "Distance Product",
    "Alias": "$(\\min, +)$ Matrix Multiplication; $(\\min, +)$ Matrix Product; Funny Matrix Multiplication",
    "Parents": "",
    "Children": "",
    "Problem Description": "Matrix product over the $(\\min, +)$-semiring",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: dimension of square matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n^2)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 6,
    "Family Name": "Matrix Product",
    "Variation": "$(\\min, \\leq)$ Product",
    "Alias": "$(\\min, \\leq)$ Matrix Multiplication",
    "Parents": "",
    "Children": "",
    "Problem Description": "Matrix product over the $(\\min, \\leq)$-semiring",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: dimension of square matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n^2)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 6,
    "Family Name": "Matrix Product",
    "Variation": "Rectangular Matrices",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 6,
    "Family Name": "Matrix Product",
    "Variation": "Dense Matrix Multiplication",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 9,
    "Family Name": "Linear System",
    "Variation": "General Linear System",
    "Alias": "",
    "Parents": "",
    "Children": "Sparse Linear System; Positive Definite, Hermitian Matrix; Non-Definite, Symmetric Matrix; Toeplitz Matrix; Vandermonde Matrix;",
    "Problem Description": "A system of linear equations (or linear system) is a collection of one or more linear equations involving the same set of variables. This is typically written in the form $Ax=b$ where $A$ is a matrix and $x, b$ are vectors. In this case, we impose no restrictions on $A$.",
    "Description Reference": "https://wires.onlinelibrary.wiley.com/doi/pdfdirect/10.1002/wics.164",
    "Parameters": "$n$: number of variables and number of equations\n$m$: number of nonzero entries in matrix\n$k$: ratio between largest and smallest eigenvalues",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n^2.37285956)",
    "Upper Bound Reference": "Matrix inverse (which has the same complexity as matrix multiplication)",
    "Best Known Lower Bound": "Omega(n^2)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 9,
    "Family Name": "Linear System",
    "Variation": "Sparse Linear System",
    "Alias": "",
    "Parents": "General Linear System",
    "Children": "",
    "Problem Description": "In this case, we restrict $A$ to be sparse (i.e. $A$ only has $O(n)$ nonzero entries).",
    "Description Reference": "https://arxiv.org/pdf/0811.3171.pdf",
    "Parameters": "$n$: number of variables and number of equations\n$m$: number of nonzero entries in matrix\n$k$: ratio between largest and smallest eigenvalues",
    "Parameter for graphs": "n^2",
    "Input Size": "O(m)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n^2.37285956) deterministic, O(n^2.331642) randomized/roughly approximate",
    "Upper Bound Reference": "https://arxiv.org/abs/2007.10254",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 9,
    "Family Name": "Linear System",
    "Variation": "Positive Definite, Hermitian Matrix",
    "Alias": "",
    "Parents": "General Linear System",
    "Children": "",
    "Problem Description": "In this case, we restrict $A$ to be positive definite and hermitian (or symmetric, if $A$ is real-valued).",
    "Description Reference": "https://www.cs.utexas.edu/users/flame/Notes/NotesOnChol.pdf",
    "Parameters": "$n$: number of variables and number of equations\n$m$: number of nonzero entries in matrix\n$k$: ratio between largest and smallest eigenvalues",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n^2.37285956)",
    "Upper Bound Reference": "Matrix inverse (which has the same complexity as matrix multiplication)",
    "Best Known Lower Bound": "Omega(n^2)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 9,
    "Family Name": "Linear System",
    "Variation": "Non-Definite, Symmetric Matrix",
    "Alias": "",
    "Parents": "General Linear System",
    "Children": "",
    "Problem Description": "In this case, we restrict $A$ to be non-definite and symmetric.",
    "Description Reference": "https://link.springer.com/article/10.1007/BF01931804",
    "Parameters": "$n$: number of variables and number of equations\n$m$: number of nonzero entries in matrix\n$k$: ratio between largest and smallest eigenvalues",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n^2.37285956)",
    "Upper Bound Reference": "Matrix inverse (which has the same complexity as matrix multiplication)",
    "Best Known Lower Bound": "Omega(n^2)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 9,
    "Family Name": "Linear System",
    "Variation": "Toeplitz Matrix",
    "Alias": "",
    "Parents": "General Linear System",
    "Children": "",
    "Problem Description": "In this case, we restrict $A$ to be a Toeplitz matrix.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF02163269.pdf",
    "Parameters": "$n$: number of variables and number of equations\n$m$: number of nonzero entries in matrix\n$k$: ratio between largest and smallest eigenvalues",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "min(O(n^2), C*O(n*log^2(n)))",
    "Upper Bound Reference": "https://en.wikipedia.org/wiki/Levinson_recursion",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 9,
    "Family Name": "Linear System",
    "Variation": "Vandermonde Matrix",
    "Alias": "",
    "Parents": "General Linear System",
    "Children": "",
    "Problem Description": "In this case, we restrict $A$ to be a Vandermonde matrix.",
    "Description Reference": "https://www.jstor.org/stable/2004623",
    "Parameters": "$n$: number of variables and number of equations\n$m$: number of nonzero entries in matrix\n$k$: ratio between largest and smallest eigenvalues",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n^2)",
    "Upper Bound Reference": "Algorithm #108",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 10,
    "Family Name": "Linear Programming",
    "Variation": "General Linear Programming",
    "Alias": "",
    "Parents": "",
    "Children": "Linear Programming with Reals;",
    "Problem Description": "Linear programming (LP; also called linear optimization) is a method to achieve the best outcome (such as maximum profit or lowest cost) in a mathematical model whose requirements are represented by linear relationships. Linear programming is a special case of mathematical programming (also known as mathematical optimization).",
    "Description Reference": "https://books.google.com/books?hl=en&lr=&id=DTjPAAAAQBAJ&oi=fnd&pg=PP1&dq=general+linear+programming&ots=vD4ZikjK9Z&sig=hKNx-yjfv4eztlHMjbWBIEWhfGA#v=onepage&q=general%20linear%20programming&f=false",
    "Parameters": "$n$: number of variables\n$m$: number of constraints\n$L$: length of input, in bits",
    "Parameter for graphs": "n",
    "Input Size": "O(L)",
    "Output Size": "O(1) for value, ~O(n) for variable values",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 10,
    "Family Name": "Linear Programming",
    "Variation": "Linear Programming with Reals",
    "Alias": "",
    "Parents": "General Linear Programming",
    "Children": "Integer Linear Programming;",
    "Problem Description": "In this case, we allow all of the variables to be any real number.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF01580859.pdf",
    "Parameters": "$n$: number of variables\n$m$: number of constraints\n$L$: length of input, in bits",
    "Parameter for graphs": "n",
    "Input Size": "O(L)",
    "Output Size": "O(1) for value, ~O(n) for variable values",
    "Best Known Upper Bound": "O(n^2.37285956*polylog(n, m, L))",
    "Upper Bound Reference": "https://arxiv.org/abs/1810.07896",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 10,
    "Family Name": "Linear Programming",
    "Variation": "Integer Linear Programming",
    "Alias": "ILP",
    "Parents": "Linear Programming with Reals",
    "Children": "0-1 Linear Programming;",
    "Problem Description": "In this case, we require all of the variables to be integers.",
    "Description Reference": "https://d1wqtxts1xzle7.cloudfront.net/30784929/15023096-libre.pdf?1392035464=&response-content-disposition=inline%3B+filename%3DThree_models_of_fuzzy_integer_linear_pro.pdf&Expires=1661187732&Signature=KJX0f8E8YpE~2X0f4tgDBvqlsPKVldp3BztygETrIDDscwI25~PAsRrtZ8JYXgalpEd1vJEuYuUDCyefMcdsMqq0I-yN0l0DOn6AaZhB-Wr-bjzxuorwUjudediDpIFtzK6t6ue30Gy5smKflevKkLzd~C9gDO9wLM7rXs9Qc3Pt3WRq~eyXrNERyyX8nQCj3-FtOFPVWttivVFqKopzQ7zHUnkMsSQ9~TOyB58tJX5mjZ0qwTnG-E5WdkYIcxSqFFMvQciOztMjOw4ztTOoaR-bK4zm23a~Rhmy9YnvyN6H807Dn4R7Gz2HhIi7fBpZKuN7TRUUDLZoYF3E6AhV1g__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA",
    "Parameters": "$n$: number of variables\n$m$: number of constraints\n$L$: length of input, in bits",
    "Parameter for graphs": "n",
    "Input Size": "O(L)",
    "Output Size": "O(1) for value, ~O(n) for variable values",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "Omega(poly(n, m, L))",
    "Lower Bound Reference": "NP-hard",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 10,
    "Family Name": "Linear Programming",
    "Variation": "0-1 Linear Programming",
    "Alias": "",
    "Parents": "Integer Linear Programming",
    "Children": "",
    "Problem Description": "In this case, we require all of the variables to be either 0 or 1.",
    "Description Reference": "https://www.jstor.org/stable/pdf/2628745.pdf",
    "Parameters": "$n$: number of variables\n$m$: number of constraints\n$L$: length of input, in bits",
    "Parameter for graphs": "n",
    "Input Size": "O(L)",
    "Output Size": "O(1) for value, ~O(n) for variable values",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "Omega(poly(n, m, L))",
    "Lower Bound Reference": "NP-hard",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 11,
    "Family Name": "Line segment intersection",
    "Variation": "Reporting all intersection points, line segments",
    "Alias": "",
    "Parents": "Reporting all intersection points, generalized segments",
    "Children": "Counting number of intersection points, line segments;",
    "Problem Description": "The line segment intersection problem supplies a list of line segments in the Euclidean plane and asks about the points where they intersect (cross), if any. In this case, we wish to report all points of intersection.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/147508.147511",
    "Parameters": "$n$: number of line segments\n$k$: number of points of intersection",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "O(n*log(n)+k)",
    "Upper Bound Reference": "https://dl.acm.org/doi/10.1145/147508.147511",
    "Best Known Lower Bound": "Omega(n*log(n)+k)",
    "Lower Bound Reference": "Reduction from element uniqueness (see https://dl.acm.org/doi/10.1145/304893.304991)",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 11,
    "Family Name": "Line segment intersection",
    "Variation": "Reporting all intersection points, generalized segments",
    "Alias": "",
    "Parents": "",
    "Children": "Reporting all intersection points, line segments;",
    "Problem Description": "In this case, the segments are generalized (i.e. have algebraic degree ≥1); we still wish to report all points of intersection.",
    "Description Reference": "https://epubs.siam.org/doi/abs/10.1137/S0097539797329373",
    "Parameters": "$n$: number of line segments\n$k$: number of points of intersection",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "O(n*log(n)+k)",
    "Upper Bound Reference": "https://dl.acm.org/citation.cfm?id=304991",
    "Best Known Lower Bound": "Omega(n*log(n)+k)",
    "Lower Bound Reference": "Reduction from element uniqueness (see https://dl.acm.org/doi/10.1145/304893.304991)",
    "Domain": "Image Processing",
    "": "<= slightly imprecise and possibly outdated here (particularly for upper bound), due to algorithms mostly solving for lower degree",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 11,
    "Family Name": "Line segment intersection",
    "Variation": "Reporting all intersection points, convex polygons",
    "Alias": "",
    "Parents": "Reporting all intersection points, general polygons",
    "Children": "",
    "Problem Description": "In this case, we are supplied with a list of convex polygons, and we wish to report all regions of intersection.",
    "Description Reference": "https://pdfs.semanticscholar.org/a571/cc92218132a1b0e65c2adbf663c79d015737.pdf",
    "Parameters": "$n$: number of line segments\n$k$: number of points of intersection",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "O(n*log(n)+k)",
    "Upper Bound Reference": "https://pdfs.semanticscholar.org/a571/cc92218132a1b0e65c2adbf663c79d015737.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 11,
    "Family Name": "Line segment intersection",
    "Variation": "Reporting all intersection points, general polygons",
    "Alias": "",
    "Parents": "",
    "Children": "Reporting all intersection points, convex polygons;",
    "Problem Description": "In this case, we are supplied with a list of polygons (not necessarily convex), and we wish to report all regions of intersection.",
    "Description Reference": "https://pdfs.semanticscholar.org/a571/cc92218132a1b0e65c2adbf663c79d015737.pdf",
    "Parameters": "$n$: number of line segments\n$k$: number of points of intersection",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "O((n+k)*log(n))",
    "Upper Bound Reference": "https://pdfs.semanticscholar.org/a571/cc92218132a1b0e65c2adbf663c79d015737.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 11,
    "Family Name": "Line segment intersection",
    "Variation": "Counting number of intersection points, line segments",
    "Alias": "",
    "Parents": "Reporting all intersection points, line segments",
    "Children": "",
    "Problem Description": "In this case, we are supplied with a list of line segments, and we wish to count the number of points of intersection.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0022000086900255",
    "Parameters": "$n$: number of line segments\n$k$: number of points of intersection",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(log k)",
    "Best Known Upper Bound": "O(min(n^1.695, n*log(n)+k))",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/0022000086900255",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "<= upper bound ref is for n^1.695",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 11,
    "Family Name": "Line segment intersection",
    "Variation": "Intersection detection (whether there exists an intersection)",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 12,
    "Family Name": "Convex Hull",
    "Variation": "2-dimensional Convex Hull",
    "Alias": "",
    "Parents": "d-dimensional Convex Hull",
    "Children": "2-dimensional Convex Hull, Online; 2-dimensional Convex Hull, Dynamic;",
    "Problem Description": "The convex hull or convex envelope or convex closure of a set X of points in the Euclidean plane or in a Euclidean space (or; more generally; in an affine space over the reals) is the smallest convex set that contains X. Here, we are looking at the 2-dimensional case.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/359423.359430",
    "Parameters": "$n$: number of line segments\n$h$: number of points on the convex hull",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(h)",
    "Best Known Upper Bound": "O(n*log(h))",
    "Upper Bound Reference": "https://ecommons.cornell.edu/handle/1813/6417",
    "Best Known Lower Bound": "Omega(n*log(h))",
    "Lower Bound Reference": "https://ecommons.cornell.edu/handle/1813/6417",
    "Domain": "Image Processing",
    "": "For more on convex hull algos in general see https://link.springer.com/chapter/10.1007/978-1-4612-1098-6_3",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 12,
    "Family Name": "Convex Hull",
    "Variation": "3-dimensional Convex Hull",
    "Alias": "",
    "Parents": "d-dimensional Convex Hull",
    "Children": "",
    "Problem Description": "Here, we are looking at the 3-dimensional case.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/359423.359430",
    "Parameters": "$n$: number of line segments\n$h$: number of points on the convex hull",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(h)",
    "Best Known Upper Bound": "O(n*log(h))",
    "Upper Bound Reference": "https://link.springer.com/article/10.1007/BF02712873",
    "Best Known Lower Bound": "Omega(n*log(h))",
    "Lower Bound Reference": "Reduction to 2-dimensional case",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 12,
    "Family Name": "Convex Hull",
    "Variation": "d-dimensional Convex Hull",
    "Alias": "",
    "Parents": "",
    "Children": "2-dimensional Convex Hull; 3-dimensional Convex Hull;",
    "Problem Description": "Here, we are looking at the general d-dimensional case.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/12130.12172",
    "Parameters": "$n$: number of line segments\n$h$: number of points on the convex hull\n$f_1$: number of facets on the convex hull\n$f_2$: number of subfacets on the convex hull",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(h)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 12,
    "Family Name": "Convex Hull",
    "Variation": "2-dimensional Convex Hull, Online",
    "Alias": "",
    "Parents": "2-dimensional Convex Hull",
    "Children": "",
    "Problem Description": "Here, we are given the input points one by one, and must maintain the current convex hull after each input point.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/359131.359132",
    "Parameters": "$n$: number of line segments\n$h$: number of points on the convex hull",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(h)",
    "Best Known Upper Bound": "O(log(n)) per operation, O(n*log(n)) total",
    "Upper Bound Reference": "https://dl.acm.org/doi/abs/10.1145/359131.359132",
    "Best Known Lower Bound": "Omega(log(n)) per operation, Omega(n*log(n)) total",
    "Lower Bound Reference": "https://link.springer.com/content/pdf/10.1007/978-1-4612-1098-6.pdf",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 12,
    "Family Name": "Convex Hull",
    "Variation": "2-dimensional Convex Hull, Dynamic",
    "Alias": "",
    "Parents": "2-dimensional Convex Hull",
    "Children": "",
    "Problem Description": "Here, the input points may be sequentially inserted or deleted, and the convex hull must be updated after each insert/delete operation.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/002200008190012X?via%3Dihub",
    "Parameters": "$n$: number of line segments\n$h$: number of points on the convex hull",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(h)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "<= for more see https://en.wikipedia.org/wiki/Dynamic_convex_hull",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "Strongly Connected Components",
    "Alias": "SCCs",
    "Parents": "",
    "Children": "",
    "Problem Description": "The strongly connected components or diconnected components of an arbitrary directed graph form a partition into subgraphs that are themselves strongly connected.",
    "Description Reference": "https://ieeexplore.ieee.org/abstract/document/6979028?casa_token=daaoBjrHUa4AAAAA:DCjk_WMWZ5Is6KvGpmS8a2bL9LskvV0P1zEG4U2u-Tm_C8sixu1w65OpTyjml1HEpaikXhtYsg",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V+E)",
    "Best Known Upper Bound": "O(V+E)",
    "Upper Bound Reference": "Many algorithms",
    "Best Known Lower Bound": "Omega(V+E)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "Connected Components in an undirected graph",
    "Alias": "CC",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "Transitive Closure",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In this problem, we also want to compute the transitive closure of a graph. (Perhaps this should be a separate problem?)",
    "Description Reference": "https://link.springer.com/article/10.1007/BF01940892",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V^2)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "Transitive Closure of a symmetric Boolean matrix",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "Maximum Strongly Connected Component",
    "Alias": "MaxSCC",
    "Parents": "",
    "Children": "",
    "Problem Description": "maintain: a directed graph, under: edge insertions/deletions, answer: what is the size of the largest SCC?",
    "Description Reference": "https://ieeexplore.ieee.org/abstract/document/6979028?casa_token=daaoBjrHUa4AAAAA:DCjk_WMWZ5Is6KvGpmS8a2bL9LskvV0P1zEG4U2u-Tm_C8sixu1w65OpTyjml1HEpaikXhtYsg",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "Strong Connectivity (dynamic)",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "maintain: a directed graph, under edge insertions/deletions, answer: is the graph strongly connected?",
    "Description Reference": "https://ieeexplore.ieee.org/abstract/document/6979028?casa_token=daaoBjrHUa4AAAAA:DCjk_WMWZ5Is6KvGpmS8a2bL9LskvV0P1zEG4U2u-Tm_C8sixu1w65OpTyjml1HEpaikXhtYsg",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "2 Strong Components (dynamic)",
    "Alias": "SC2",
    "Parents": "",
    "Children": "",
    "Problem Description": "maintain: a directed graph, under: edge insertion/deletions, answer: are there more than 2 strongly connected components?",
    "Description Reference": "https://ieeexplore.ieee.org/abstract/document/6979028?casa_token=daaoBjrHUa4AAAAA:DCjk_WMWZ5Is6KvGpmS8a2bL9LskvV0P1zEG4U2u-Tm_C8sixu1w65OpTyjml1HEpaikXhtYsg",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "Connected Subgraph",
    "Alias": "ConnSub",
    "Parents": "",
    "Children": "",
    "Problem Description": "Subgraph connectivity asks us to maintainan understanding of connectivity under vertex updates: updates can turn vertices on and off, and queries refer to the subgraph induced by \"on\" vertices. (For instance, this is closer to applications in networks of routers, where node faults may occur.)",
    "Description Reference": "https://ieeexplore.ieee.org/abstract/document/6979028?casa_token=daaoBjrHUa4AAAAA:DCjk_WMWZ5Is6KvGpmS8a2bL9LskvV0P1zEG4U2u-Tm_C8sixu1w65OpTyjml1HEpaikXhtYsg",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 13,
    "Family Name": "Strongly Connected Components",
    "Variation": "Biconnected Components",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 14,
    "Family Name": "Minimum Spanning Tree (MST)",
    "Variation": "Undirected, General MST",
    "Alias": "",
    "Parents": "",
    "Children": "Undirected, Dense MST; Undirected, Planar MST; Undirected, Integer Weights MST;",
    "Problem Description": "A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected; edge-weighted undirected graph that connects all the vertices together; without any cycles and with the minimum possible total edge weight. Here, there are no restrictions on edge weights or graph density.",
    "Description Reference": "https://dl.acm.org/citation.cfm?id=2791225",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge weight",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "Unknown but matches lower bound",
    "Upper Bound Reference": "https://dl.acm.org/doi/10.1145/505241.505243",
    "Best Known Lower Bound": "Unknown but matches upper bound",
    "Lower Bound Reference": "https://dl.acm.org/doi/10.1145/505241.505243",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 14,
    "Family Name": "Minimum Spanning Tree (MST)",
    "Variation": "Undirected, Dense MST",
    "Alias": "",
    "Parents": "Undirected, General MST",
    "Children": "",
    "Problem Description": "A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected; edge-weighted undirected graph that connects all the vertices together; without any cycles and with the minimum possible total edge weight. Here, we assume that the graph is dense (i.e. $E = \\Omega(V)$).",
    "Description Reference": "https://epubs.siam.org/doi/abs/10.1137/0205051",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge weight",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "O(E)",
    "Upper Bound Reference": "https://epubs.siam.org/doi/abs/10.1137/0205051",
    "Best Known Lower Bound": "Omega(E)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 14,
    "Family Name": "Minimum Spanning Tree (MST)",
    "Variation": "Undirected, Planar MST",
    "Alias": "",
    "Parents": "Undirected, General MST",
    "Children": "",
    "Problem Description": "A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected; edge-weighted undirected graph that connects all the vertices together; without any cycles and with the minimum possible total edge weight. Here, we assume that the graph is planar.",
    "Description Reference": "https://epubs.siam.org/doi/abs/10.1137/0205051",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge weight",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "O(V)",
    "Upper Bound Reference": "https://epubs.siam.org/doi/abs/10.1137/0205051",
    "Best Known Lower Bound": "Omega(V)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 14,
    "Family Name": "Minimum Spanning Tree (MST)",
    "Variation": "Undirected, Integer Weights MST",
    "Alias": "",
    "Parents": "Undirected, General MST",
    "Children": "",
    "Problem Description": "A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected; edge-weighted undirected graph that connects all the vertices together; without any cycles and with the minimum possible total edge weight. Here, we assume that the edges have integer weights, represented in binary.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/S0022000005800649?via%3Dihub",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge weight",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "O(E)",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/S0022000005800649?via%3Dihub",
    "Best Known Lower Bound": "Omega(E)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 14,
    "Family Name": "Minimum Spanning Tree (MST)",
    "Variation": "Directed (Optimum Branchings), General MST",
    "Alias": "",
    "Parents": "",
    "Children": "Directed (Optimum Branchings), Super Dense MST;",
    "Problem Description": "A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected; edge-weighted undirected graph that connects all the vertices together; without any cycles and with the minimum possible total edge weight. Here, we're given a directed graph with a root, and we wish to find a spanning arborescence of minimum weight that is rooted at the root.",
    "Description Reference": "https://nvlpubs.nist.gov/nistpubs/jres/71b/jresv71bn4p233_a1b.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge weight",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "O(E+VlogV)",
    "Upper Bound Reference": "https://link.springer.com/article/10.1007/BF02579168",
    "Best Known Lower Bound": "Omega(E)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 14,
    "Family Name": "Minimum Spanning Tree (MST)",
    "Variation": "Directed (Optimum Branchings), Super Dense MST",
    "Alias": "",
    "Parents": "Directed (Optimum Branchings), General MST",
    "Children": "",
    "Problem Description": "A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected; edge-weighted undirected graph that connects all the vertices together; without any cycles and with the minimum possible total edge weight. Here, we're given a directed graph with a root and $E=\\Omega(V^2)$ edges, and we wish to find a spanning arborescence of minimum weight that is rooted at the root.",
    "Description Reference": "https://onlinelibrary.wiley.com/doi/10.1002/net.3230070103",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$U$: maximum edge weight",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogU)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "O(V^2)",
    "Upper Bound Reference": "https://onlinelibrary.wiley.com/doi/10.1002/net.3230070103",
    "Best Known Lower Bound": "Omega(V^2)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 14,
    "Family Name": "Minimum Spanning Tree (MST)",
    "Variation": "Directed Spanning Forest",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 14,
    "Family Name": "Minimum Spanning Tree (MST)",
    "Variation": "all but very sparse graphs",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 15,
    "Family Name": "Closest Pair Problem",
    "Variation": "k-dimensional space, $l_m$ (or $l_\\infty$) norm",
    "Alias": "",
    "Parents": "",
    "Children": "2-dimensional space, $l_m$ (or $l_\\infty$) norm;",
    "Problem Description": "Given $n$ points in metric space, typically $k$-dimensional space equipped with $l_m$ (or $l_\\infty$) norm, find a pair of points with the smallest distance between them.",
    "Description Reference": "https://dl.acm.org/citation.cfm?id=540196",
    "Parameters": "$n$: number of points\n$k$: dimension of space",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "O(kn loglogn+n*3^k) or O(kn logn)",
    "Upper Bound Reference": "Divide-and-conquer or Fortune-Hopcruft algorithm",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "<= has a dynamic version that's worth exploring",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 15,
    "Family Name": "Closest Pair Problem",
    "Variation": "2-dimensional space, $l_m$ (or $l_\\infty$) norm",
    "Alias": "",
    "Parents": "k-dimensional space, $l_m$ (or $l_\\infty$) norm",
    "Children": "",
    "Problem Description": "Given $n$ points in 2-dimensional space equipped with the $l_m$ (or $l_\\infty$) norm, find a pair of points with the smallest distance between them.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0020019088901500",
    "Parameters": "$n$: number of points\n$k$: dimension of space",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 15,
    "Family Name": "Closest Pair Problem",
    "Variation": "2-dimensional space, Euclidean metric",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given $n$ points in 2-dimensional space equipped with the Eucildean metric, find a pair of points with the smallest distance between them.",
    "Description Reference": "https://ieeexplore.ieee.org/document/4567872",
    "Parameters": "$n$: number of points\n$k$: dimension of space",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 15,
    "Family Name": "Closest Pair Problem",
    "Variation": "Euclidean space in k dimensions",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 15,
    "Family Name": "Closest Pair Problem",
    "Variation": "2-dimensional array representation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given $n$ points in 2-dimensional space in array representation, find a pair of points with the smallest distance between them.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0020019080900356",
    "Parameters": "$n$: number of points\n$k$: dimension of space",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "General Weights",
    "Alias": "",
    "Parents": "",
    "Children": "Nonnegative Weights;",
    "Problem Description": "The shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized. Here, the weights can be any real number.",
    "Description Reference": "https://apps.dtic.mil/sti/pdfs/AD0422842.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogL)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "General Weights, Undirected",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Nonnegative Weights",
    "Alias": "",
    "Parents": "general weights",
    "Children": "Nonnegative Integer Weights;",
    "Problem Description": "The shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized. Here, the weights are restricted to be nonnegative.",
    "Description Reference": "https://www.jstor.org/stable/3007178?seq=1#page_scan_tab_contents",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogL)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "O(E + V log V)",
    "Upper Bound Reference": "https://www.cs.princeton.edu/courses/archive/fall03/cs528/handouts/fibonacci%20heaps.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Nonnegative Weights, Undirected",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Undirected, Nonnegative Weights",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Nonnegative Integer Weights",
    "Alias": "",
    "Parents": "nonnegative weights",
    "Children": "",
    "Problem Description": "The shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized. Here, the weights are restricted to be nonnegative integers.",
    "Description Reference": "https://doi.org/10.1016/0166-218X(83)90104-X",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "O(ElogL)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "O(E + V min(log log V, log log L))",
    "Upper Bound Reference": "https://dl.acm.org/doi/10.1016/j.jcss.2004.04.003",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Nonnegative Weighted Digraph",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Nonnegative Integer Weighted Digraph",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Weighted Digraph",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Second Shortest Simple Path",
    "Alias": "",
    "Parents": "st-Shortest Path",
    "Children": "",
    "Problem Description": "Given a weighted digraph $G=(V,E)$, find the second shortest path between two given vertices $s$ and $t$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "st-Shortest Path",
    "Alias": "",
    "Parents": "",
    "Children": "Second Shortest Simple Path; 2-sensitive (7/5)-approximate st-shortest paths; 1-sensitive decremental st-shortest paths; 2-sensitive decremental st-shortest paths; Replacement Paths Problem;",
    "Problem Description": "Given a weighted digraph $G=(V,E)$, find the shortest path between two given vertices $s$ and $t$.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "1-sensitive (3/2)-approximate ss-shortest paths",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Approximate the single source shortest paths problem within a factor of 3/2 with a sensitivity of 1.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "2-sensitive (7/5)-approximate st-shortest paths",
    "Alias": "",
    "Parents": "st-Shortest Path",
    "Children": "",
    "Problem Description": "Approximate the st-shortest paths problem within a factor of 7/5 with a sensitivity of 2.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "1-sensitive decremental st-shortest paths",
    "Alias": "",
    "Parents": "st-Shortest Path",
    "Children": "",
    "Problem Description": "Determine the st-shortest path with a sensitivity of 1 using decremental techniques.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "2-sensitive decremental st-shortest paths",
    "Alias": "",
    "Parents": "st-Shortest Path",
    "Children": "",
    "Problem Description": "Determine the st-shortest path with a sensitivity of 2 using decremental techniques.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 16,
    "Family Name": "Shortest Path (Directed Graphs)",
    "Variation": "Replacement Paths Problem",
    "Alias": "RPP",
    "Parents": "st-Shortest Path",
    "Children": "",
    "Problem Description": "Given nodes $s$ and $t$ in a weighted directed graph and a shortest path $P$ from $s$ to $t$, compute the length of the shortest simple path that avoids edge $e$, for all edges $e$ on $P$",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges\n$L$: maximum absolute value of edge cost",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP",
    "Alias": "All-Pairs Shortest Paths",
    "Parents": "",
    "Children": "APSP on Dense Directed Graphs with Arbitrary Weights; APSP on Dense Undirected Graphs with Arbitrary Weights; APSP on Geometrically Weighted Graphs; APSP on Dense Undirected Graphs with Positive Integer Weights; APSP on Sparse Directed Graphs with Arbitrary Weights; APSP on Sparse Undirected Graphs with Positive Integer Weights; APSP on Sparse Undirected Graphs with Arbitrary Weights; APSP on Dense Directed Unweighted Graphs; APSP on Dense Undirected Unweighted Graphs; APSP on Sparse Directed Unweighted Graphs; APSP on Sparse Undirected Unweighted Graphs; (5/3)-approximate ap-shortest paths;",
    "Problem Description": "The shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/2591796.2591811",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Dense Directed Graphs with Arbitrary Weights",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is dense ($m = O(n^2)$), is directed, and has arbitrary weights.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/2591796.2591811",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Dense Undirected Graphs with Arbitrary Weights",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is dense ($m = O(n^2)$), is undirected, and has arbitrary weights.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/2591796.2591811",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Geometrically Weighted Graphs",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider may be dense or sparse, may be directed or undirected, and has weights from a fixed set of $c$ values.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/2591796.2591811",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$c$: number of unique weights",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Dense Undirected Graphs with Positive Integer Weights",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is dense ($m = O(n^2)$), is undirected, and has positive integer weights.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/2591796.2591811",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Sparse Directed Graphs with Arbitrary Weights",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is sparse ($m = O(n)$), is directed, and has arbitrary weights.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/321992.321993",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Sparse Undirected Graphs with Positive Integer Weights",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is sparse ($m = O(n)$), is undirected, and has positive integer weights.",
    "Description Reference": "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.7128&rep=rep1&type=pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Sparse Undirected Graphs with Arbitrary Weights",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is sparse ($m = O(n)$), is undirected, and has arbitrary weights.",
    "Description Reference": "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.7128&rep=rep1&type=pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Dense Directed Unweighted Graphs",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is dense ($m = O(n^2)$), is directed, and is unweighted (or equivalently, has all unit weights).",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/567112.567114",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Dense Undirected Unweighted Graphs",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is dense ($m = O(n^2)$), is undirected, and is unweighted (or equivalently, has all unit weights).",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/S0022000085710781?via%3Dihub",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Sparse Directed Unweighted Graphs",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is sparse ($m = O(n)$), is directed, and is unweighted (or equivalently, has all unit weights).",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/567112.567114",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "APSP on Sparse Undirected Unweighted Graphs",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "In this case, the graph $G=(V,E)$ that we consider is sparse ($m = O(n)$), is undirected, and is unweighted (or equivalently, has all unit weights).",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/S0022000085710781?via%3Dihub",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 17,
    "Family Name": "All-Pairs Shortest Paths (APSP)",
    "Variation": "(5/3)-approximate ap-shortest paths",
    "Alias": "",
    "Parents": "APSP",
    "Children": "",
    "Problem Description": "Approximate APSP within a factor of 5/3.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 18,
    "Family Name": "Integer Factoring",
    "Variation": "Smallest Factor",
    "Alias": "First Category Integer Factoring",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an $n$-bit integer $N$, find a non-trivial factorization $N=pq$ (where $p, q>1$ are integers) or return that $N$ is prime. For \"first category\" algorithms, the running time depends on the size of smallest prime factor.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF01933667.pdf",
    "Parameters": "$n$: number of bits in the integer\n$B$: bound parameter (if needed)",
    "Parameter for graphs": "n",
    "Input Size": "n",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(exp((1+o(1))(32n/9)^(1/3)(log n)^(2/3)) heuristically?",
    "Upper Bound Reference": "Special Number Field Sieve",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 18.5,
    "Family Name": "Integer Factoring",
    "Variation": "UNLISTED VARIATION",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 19,
    "Family Name": "Integer Factoring",
    "Variation": "Integer Factoring",
    "Alias": "Second Category Integer Factoring",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an $n$-bit integer $N$, find a non-trivial factorization $N=pq$ (where $p, q>1$ are integers) or return that $N$ is prime. For \"second category\" algorithms, the running time depends solely on the size of the integer to be factored",
    "Description Reference": "https://www.ams.org/journals/mcom/1981-36-153/S0025-5718-1981-0595059-1/home.html",
    "Parameters": "$n$: number of bits in the integer",
    "Parameter for graphs": "n",
    "Input Size": "n",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(exp((1+o(1))(64n/9)^(1/3)(log n)^(2/3)) heuristically?",
    "Upper Bound Reference": "General Number Field Sieve",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "https://core.ac.uk/download/pdf/301669364.pdf",
    "__1": "<= possibly good survey?",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 20,
    "Family Name": "LU Decomposition",
    "Variation": "Rectangular Matrix LU Decomposition",
    "Alias": "",
    "Parents": "",
    "Children": "Square Matrix LU Decomposition;",
    "Problem Description": "Lower–upper (LU) decomposition or factorization factors a matrix as the product of a lower triangular matrix and an upper triangular matrix. In the general case, the input is an $m \\times n$ matrix.",
    "Description Reference": "https://arxiv.org/abs/math/0506382",
    "Parameters": "$m$: number of rows in input matrix\n$n$: number of columns in input matrix\n$l$: number of columns chosen to use in the decomposition ($l \\geq k$)\n$k$: desired rank of decomposition",
    "Parameter for graphs": "mn",
    "Input Size": "mn",
    "Output Size": "O(mn)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 20,
    "Family Name": "LU Decomposition",
    "Variation": "Square Matrix LU Decomposition",
    "Alias": "",
    "Parents": "Rectangular Matrix LU Decomposition",
    "Children": "",
    "Problem Description": "Lower–upper (LU) decomposition or factorization factors a matrix as the product of a lower triangular matrix and an upper triangular matrix. In this specific case, the input is a square $n \\times n$ matrix",
    "Description Reference": "https://arxiv.org/abs/math/0506382",
    "Parameters": "$n$: dimension of square matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "n^2",
    "Output Size": "O(n^2)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 20,
    "Family Name": "LU Decomposition",
    "Variation": "Dense Matrix LU Decomposition",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 21,
    "Family Name": "Informed Search",
    "Variation": "Informed Search",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Informed search tries to reduce the amount of search that must be done by making intelligent choices for the nodes that are selected for expansion.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4082128",
    "Parameters": "$b$: branching factor (the average number of successors per state)\n$d$: the depth of the solution (the shortest path)\n$n$: total number of nodes",
    "Parameter for graphs": "d",
    "Input Size": "O(n)",
    "Output Size": "O(d)",
    "Best Known Upper Bound": "O(b^d)",
    "Upper Bound Reference": "D* Lite",
    "Best Known Lower Bound": "O(d)",
    "Lower Bound Reference": "Trivial (there could be a stronger one from APSP?)",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 22,
    "Family Name": "String Search",
    "Variation": "Single String Search",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Single string search algorithms try to find a place where a string (also called a pattern) is found within a larger string or text.",
    "Description Reference": "http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Knuth77.pdf",
    "Parameters": "$m$: pattern length\n$n$: length of searchable text\n$s$: size of the alphabet",
    "Parameter for graphs": "m+n",
    "Input Size": "n+m+s",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 22,
    "Family Name": "String Search",
    "Variation": "Multiple String Search",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Multiple string search algorithms try to find a place where one or several strings (also called patterns) are found within a larger string or text.",
    "Description Reference": "http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Knuth77.pdf",
    "Parameters": "$m$: longest pattern length\n$n$: length of searchable text\n$s$: size of the alphabet\n$k$: number of patterns to search for\n$z$: number of matches",
    "Parameter for graphs": "m+n",
    "Input Size": "n+O(km)+s",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "$O(n + m + z)$",
    "Upper Bound Reference": "https://cr.yp.to/bib/1975/aho.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 23,
    "Family Name": "Sequence Alignment",
    "Variation": "Edit Distance, constant-size alphabet",
    "Alias": "",
    "Parents": "",
    "Children": "Edit Sequence, constant-size alphabet;",
    "Problem Description": "Given two strings, determine the minimum number of edits required to transform one of the strings into the other. Assume we have a constant-size alphabet.",
    "Description Reference": "https://doi.org/10.1016/0022-0000(80)90002-1",
    "Parameters": "$m,n$: lengths of input strings; assume $m\\leq n$",
    "Parameter for graphs": "m+n",
    "Input Size": "m+n",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "O(mn/log^2(n))",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/0022000080900021?via%3Dihub",
    "Best Known Lower Bound": "Omega((mn)^(1-eps)) for any eps>0",
    "Lower Bound Reference": "Reduction #4",
    "Domain": "Bioinformatics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 23,
    "Family Name": "Sequence Alignment",
    "Variation": "Edit Sequence, constant-size alphabet",
    "Alias": "",
    "Parents": "Edit Distance, constant-size alphabet",
    "Children": "",
    "Problem Description": "Given two strings, determine the shortest sequence of edits required to transform one of the strings into the other. Assume we have a constant-size alphabet.",
    "Description Reference": "https://doi.org/10.1016/0022-0000(80)90002-1",
    "Parameters": "$m,n$: lengths of input strings; assume $m\\leq n$",
    "Parameter for graphs": "m+n",
    "Input Size": "m+n",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(mn/log^2(n))",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/0022000080900021?via%3Dihub",
    "Best Known Lower Bound": "Omega((mn)^(1-eps)) for any eps>0",
    "Lower Bound Reference": "Reduction #4",
    "Domain": "Bioinformatics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 24,
    "Family Name": "Joins",
    "Variation": "Joins",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "An SQL join clause - corresponding to a join operation in relational algebra - combines columns from one or more tables in a relational database.",
    "Description Reference": "https://www.w3schools.com/sql/sql_join.asp",
    "Parameters": "$m,n$: sizes of input tables",
    "Parameter for graphs": "m+n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Databases",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 25,
    "Family Name": "Line Clipping",
    "Variation": "Rectangular Window",
    "Alias": "",
    "Parents": "Convex Polygonal Window",
    "Children": "",
    "Problem Description": "Line clipping is the process of removing lines or portions of lines outside an area of interest. Typically; any line or part thereof which is outside of the viewing area is removed. Here, the viewing area is rectangular.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/357332.357333",
    "Parameters": "$n$: number of lines",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "Many, e.g. https://dl.acm.org/doi/10.1145/357332.357333",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 25,
    "Family Name": "Line Clipping",
    "Variation": "Convex Polygonal Window",
    "Alias": "",
    "Parents": "Convex Polyhedral Window",
    "Children": "Rectangular Window;",
    "Problem Description": "Line clipping is the process of removing lines or portions of lines outside an area of interest. Typically; any line or part thereof which is outside of the viewing area is removed. Here, the viewing area is a convex polygon.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0097849378900213",
    "Parameters": "$n$: number of lines\n$p$: number of edges on polygon",
    "Parameter for graphs": "n",
    "Input Size": "O(n+p)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n*log(p))",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/0097849394900647/pdf?md5=06bd1f11031af17d1fd34626c4e2f49b&pid=1-s2.0-0097849394900647-main.pdf",
    "Best Known Lower Bound": "Omega(n+p)?",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 25,
    "Family Name": "Line Clipping",
    "Variation": "Convex Polyhedral Window",
    "Alias": "",
    "Parents": "",
    "Children": "Convex Polygonal Window;",
    "Problem Description": "Line clipping is the process of removing lines or portions of lines outside an area of interest. Typically; any line or part thereof which is outside of the viewing area is removed. Here, the viewing area is a convex polyhedron.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0097849378900213",
    "Parameters": "$n$: number of lines\n$p$: number of faces on polyhedron",
    "Parameter for graphs": "n",
    "Input Size": "O(n+p)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(np)",
    "Upper Bound Reference": "https://onlinelibrary.wiley.com/doi/abs/10.1111/1467-8659.1510061",
    "Best Known Lower Bound": "Omega(n+p)?",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 26,
    "Family Name": "NFA to DFA conversion",
    "Variation": "NFA to DFA conversion",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Convert a given nondeterministic finite automota (NFA) to a deterministic finite automota (DFA).",
    "Description Reference": "https://ieeexplore.ieee.org/document/5392601",
    "Parameters": "$n$: number of states in the given NFA",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 27,
    "Family Name": "Multiplication",
    "Variation": "Multiplication",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Multiplication is one of the four elementary mathematical operations of arithmetic; with the others being addition; subtraction and division. Given two $n$-bit integers, compute their product, which should be a $2n$-bit integer.",
    "Description Reference": "https://mathworld.wolfram.com/Multiplication.html",
    "Parameters": "$n$: length of one of the integers, in bits",
    "Parameter for graphs": "n",
    "Input Size": "2n",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n*logn)",
    "Upper Bound Reference": "https://hal.archives-ouvertes.fr/hal-02070778",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 28,
    "Family Name": "Maximum Cardinality Matching",
    "Variation": "Bipartite Graph MCM",
    "Alias": "",
    "Parents": "General Graph MCM",
    "Children": "Planar Bipartite Graph Perfect Matching;",
    "Problem Description": "The goal of maximum cardinality matching is to find a matching with as many edges as possible (equivalently: a matching that covers as many vertices as possible). Here, the graph is bipartite.",
    "Description Reference": "https://epubs.siam.org/doi/epdf/10.1137/0202019",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 28,
    "Family Name": "Maximum Cardinality Matching",
    "Variation": "General Graph MCM",
    "Alias": "",
    "Parents": "",
    "Children": "Bipartite Graph MCM;",
    "Problem Description": "The goal of maximum cardinality matching is to find a matching with as many edges as possible (equivalently: a matching that covers as many vertices as possible). Here, the graph can be any general graph.",
    "Description Reference": "https://web.eecs.umich.edu/~pettie/matching/Blum-matching-ICALP90.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 28,
    "Family Name": "Maximum Cardinality Matching",
    "Variation": "Planar Bipartite Graph Perfect Matching",
    "Alias": "",
    "Parents": "Bipartite Graph MCM",
    "Children": "",
    "Problem Description": "The goal of maximum cardinality matching is to find a matching with as many edges as possible (equivalently: a matching that covers as many vertices as possible). Here, the graph is a planar bipartite graph.",
    "Description Reference": "http://theory.stanford.edu/~virgi/cs267/papers/planar-sssp.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 29,
    "Family Name": "Key Exchange",
    "Variation": "Key Exchange",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Key exchange (also key establishment) is a method in cryptography by which cryptographic keys are exchanged between two parties, allowing use of a cryptographic algorithm.",
    "Description Reference": "https://caislab.kaist.ac.kr/lecture/2010/spring/cs548/basic/B08.pdf",
    "Parameters": "$n$: maximum size of numbers (prime, parameters, keys), in bits",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "(none)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Cryptography",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 30,
    "Family Name": "Mutual Exclusion",
    "Variation": "Mutual Exclusion",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Mutual exclusion is a property of concurrency control; which is instituted for the purpose of preventing race conditions.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.5555/6649",
    "Parameters": "$n$: number of processors",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 31,
    "Family Name": "SDD Systems Solvers",
    "Variation": "Exact Laplacian Solver",
    "Alias": "Symmetric Diagonally Dominant System Solvers",
    "Parents": "",
    "Children": "",
    "Problem Description": "This problem refers to solving equations of the form $Lx = b$ where $L$ is a Laplacian of a graph. In other words, this is solving equations of the form $Ax = b$ for a SDD matrix $A$.\n\nThis variation of the problem requires an exact solution with no error.",
    "Description Reference": "https://theory.epfl.ch/vishnoi/Lxb-Web.pdf",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 31,
    "Family Name": "SDD Systems Solvers",
    "Variation": "Inexact Laplacian Solver",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "This problem refers to solving equations of the form $Lx = b$ where $L$ is a Laplacian of a graph. In other words, this is solving equations of the form $Ax = b$ for a SDD matrix $A$.\n\nThis variation of the problem permits some error.",
    "Description Reference": "https://theory.epfl.ch/vishnoi/Lxb-Web.pdf",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 32,
    "Family Name": "Cycle Detection",
    "Variation": "Cycle Detection",
    "Alias": "Cycle Finding; Loop Detection",
    "Parents": "",
    "Children": "",
    "Problem Description": "Cycle detection or cycle finding is the algorithmic problem of finding a cycle in a sequence of iterated function values.",
    "Description Reference": "http://bvicam.in/INDIACom/BJIT/downloads/BIJIT%20-%20Complete%20Issue%2012.pdf#page=25",
    "Parameters": "$t_f$: time to perform one evaluation of $f$\n$\\mu$: the starting index of the cycle\n$\\lambda$: the period of the cycle\n$M$: number of values stored",
    "Parameter for graphs": "\\mu",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "$t_f (\\mu + \\lambda)(1+\\Theta(1/sqrt(M)))$",
    "Upper Bound Reference": "Algorithm #324",
    "Best Known Lower Bound": "(\\mu + \\lambda)(1 + 1/(M-1))",
    "Lower Bound Reference": "https://www.sciencedirect.com/science/article/pii/0304397585900441?via%3Dihub",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 33,
    "Family Name": "Generating Random Permutations",
    "Variation": "General Permutations",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an input string/array, generate a single random permutation of the characters/elements of the string/array.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/364520.364540",
    "Parameters": "$n$: number of elements",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "Durstenfeld's Algorithm 235",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 33,
    "Family Name": "Generating Random Permutations",
    "Variation": "Cyclic Permutations",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an input string/array, generate a single random cyclic permutation of the characters/elements of the string/array.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0020019086900736",
    "Parameters": "$n$: number of elements",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "Sattolo's algorithm",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 34,
    "Family Name": "Convex Optimization (Non-linear)",
    "Variation": "Convex Optimization (Non-linear)",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Convex optimization is a subfield of mathematical optimization that studies the problem of minimizing convex functions over convex sets.",
    "Description Reference": "https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf",
    "Parameters": "$n$: number of variables\n$m$: number of constraints\n$L$: length of input, in bits",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 35,
    "Family Name": "Gröbner Bases",
    "Variation": "Gröbner Bases",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In mathematics, and more specifically in computer algebra, computational algebraic geometry, and computational commutative algebra, a Gröbner basis is a particular kind of generating set of an ideal in a polynomial ring $K[x_1, \\ldots ,x_n]$ over a field $K$. As an algorithmic problem, given a set of polynomials in $K[x_1, \\ldots,x_n]$, determine a Gröbner basis.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/1088216.1088219",
    "Parameters": "$n$: number of variables in each polynomial\n$d$: maximal total degree of the polynomials",
    "Parameter for graphs": "n",
    "Input Size": "(potentially massive)",
    "Output Size": "(potentially massive)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 36,
    "Family Name": "Minimum value in each row of an implicitly-defined totally monotone matrix",
    "Variation": "Minimum value in each row of an implicitly-defined totally monotone matrix",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a totally monotone matrix $A$ whose entries $A[i, j]$ are implicitly defined by some function $f(i, j)$ (assume $f$ takes constant time to evaluate for all relevant $(i, j)$), determine the minimum value in each row.",
    "Description Reference": "https://link.springer.com/article/10.1007/BF01840359",
    "Parameters": "$m,n$: dimensions of matrix; assume $m≥n$\npossibly uses a function $f$ to define entries; assume evaluation of $f$ takes time $O(1)$",
    "Parameter for graphs": "mn",
    "Input Size": "O(mn)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n(1+log(n/m)))",
    "Upper Bound Reference": "SMAWK algorithm",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 37,
    "Family Name": "All Permutations",
    "Variation": "All Permutations",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Generate all permuttaions of the characters/elements in a string/array.",
    "Description Reference": "https://doi.org/10.1090/S0025-5718-1963-0159764-2",
    "Parameters": "$n$: number of elements",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n) per permutation, or O(1) if in-situ",
    "Best Known Upper Bound": "O(1) per permutation",
    "Upper Bound Reference": "Heap's algorithm, among others",
    "Best Known Lower Bound": "Omega(1) per permutation",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "https://dl.acm.org/doi/10.1145/356689.356692",
    "__1": "<= big survey",
    "__2": "https://en.wikipedia.org/wiki/Permutation#Generation_with_minimal_changes",
    "__3": "<= also more here"
  },
  {
    "Old Family #": 38,
    "Family Name": "Optimal Binary Search Trees",
    "Variation": "Optimal Binary Search Tree Problem",
    "Alias": "OBST",
    "Parents": "",
    "Children": "Approximate OBST; Huffman Encoding; Alphabetic Tree Problem;",
    "Problem Description": "Suppose we are given $n$ keys and the probabilities of accessing each key and those occurring in the gap between two successive keys. The optimal binary search tree problem is to construct a binary search tree on these $n$ keys that minimizes the expected access time.",
    "Description Reference": "https://doi.org/10.1016/S0304-3975(96)00320-9",
    "Parameters": "$n$: number of elements",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 38,
    "Family Name": "Optimal Binary Search Trees",
    "Variation": "Approximate OBST",
    "Alias": "",
    "Parents": "Optimal Binary Search Tree Problem",
    "Children": "",
    "Problem Description": "Suppose we are given $n$ keys and the probabilities of accessing each key and those occurring in the gap between two successive keys. The approximate optimal binary search tree problem is to construct a binary search tree on these $n$ keys, whose expected access time is within an approximation factor of the optimal time.",
    "Description Reference": "https://doi.org/10.1016/S0304-3975(96)00320-9",
    "Parameters": "$n$: number of elements",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 38,
    "Family Name": "Optimal Binary Search Trees",
    "Variation": "Huffman Encoding",
    "Alias": "Huffman Tree Problem",
    "Parents": "Optimal Binary Search Tree Problem",
    "Children": "",
    "Problem Description": "A related problem to the OBST problem is when there is no order between the keys and there are probabilities associated only with the gaps and the objective is to build a binary tree with minimum expected weighted path length from the root. This is called the Huffman Tree Problem",
    "Description Reference": "https://doi.org/10.1016/S0304-3975(96)00320-9",
    "Parameters": "$n$: number of elements",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 38,
    "Family Name": "Optimal Binary Search Trees",
    "Variation": "Alphabetic Tree Problem",
    "Alias": "",
    "Parents": "Optimal Binary Search Tree Problem",
    "Children": "",
    "Problem Description": "A variant of the OBST problem is when only the gaps have nonzero access probabilities, and is called the optimal alphabetic tree problem.",
    "Description Reference": "https://doi.org/10.1016/S0304-3975(96)00320-9",
    "Parameters": "$n$: number of elements",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 39,
    "Family Name": "Nash Equilibria",
    "Variation": "2-Player",
    "Alias": "",
    "Parents": "n-player",
    "Children": "",
    "Problem Description": "In game theory, the Nash equilibrium, named after the mathematician John Forbes Nash Jr., is a proposed solution of a non-cooperative game involving two or more players in which each player is assumed to know the equilibrium strategies of the other players, and no player has anything to gain by changing only his own strategy. As an algorithmic problem, given the payoff matrices for a bimatrix game, determine a Nash equilibrium.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/779928.779933",
    "Parameters": "$m,n$: dimensions of payoff matrices",
    "Parameter for graphs": "mn",
    "Input Size": "O(mn)",
    "Output Size": "O(m+n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "https://www.sciencedirect.com/science/article/pii/S0899825606000935?via%3Dihub",
    "__1": "<= look into this?",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 39,
    "Family Name": "Nash Equilibria",
    "Variation": "n-Player",
    "Alias": "",
    "Parents": "",
    "Children": "2-Player;",
    "Problem Description": "Here, given the payoff matrices for an $n$-player game, determine a Nash equilibrium.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/779928.779933",
    "Parameters": "$n$: number of players",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 40,
    "Family Name": "Maximum-Weight Matching",
    "Variation": "Maximum-Weight Matching",
    "Alias": "",
    "Parents": "",
    "Children": "Bipartite Maximum-Weight Matching;",
    "Problem Description": "In computer science, the maximum weight matching problem is the problem of finding, in a weighted graph, a matching in which the sum of weights is maximized. Here, the graph is unrestricted; i.e. can be any general graph.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1366244",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$N$: largest weight magnitude",
    "Parameter for graphs": "n",
    "Input Size": "O(mlogN)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 40,
    "Family Name": "Maximum-Weight Matching",
    "Variation": "Bipartite Maximum-Weight Matching",
    "Alias": "",
    "Parents": "Maximum-Weight Matching",
    "Children": "",
    "Problem Description": "In computer science, the maximum weight matching problem is the problem of finding, in a weighted graph, a matching in which the sum of weights is maximized. Here, the graph must be bipartite.",
    "Description Reference": "https://ieeexplore.ieee.org/abstract/document/6979028?casa_token=daaoBjrHUa4AAAAA:DCjk_WMWZ5Is6KvGpmS8a2bL9LskvV0P1zEG4U2u-Tm_C8sixu1w65OpTyjml1HEpaikXhtYsg",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$N$: largest weight magnitude",
    "Parameter for graphs": "n",
    "Input Size": "O(mlogN)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "https://web.eecs.umich.edu/~pettie/papers/ApproxMWM-JACM.pdf",
    "__1": "<= has big tables of algorithm runtimes",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 41,
    "Family Name": "Constructing Eulerian Trails in a Graph",
    "Variation": "Constructing Eulerian Trails in a Graph",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In graph theory, an Eulerian trail (or Eulerian path) is a trail in a finite graph that visits every edge exactly once (allowing for revisiting vertices). Similarly, an Eulerian circuit or Eulerian cycle is an Eulerian trail that starts and ends on the same vertex.",
    "Description Reference": "https://drops.dagstuhl.de/opus/volltexte/2016/6474/pdf/LIPIcs-MFCS-2016-62.pdf",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 42,
    "Family Name": "Discrete Fourier Transform",
    "Variation": "Discrete Fourier Transform",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In mathematics, the discrete Fourier transform (DFT) converts a finite sequence of equally-spaced samples of a function into a same-length sequence of equally-spaced samples of the discrete-time Fourier transform (DTFT), which is a complex-valued function of frequency.",
    "Description Reference": "https://www.ams.org/journals/mcom/1978-32-141/S0025-5718-1978-0468306-4/S0025-5718-1978-0468306-4.pdf",
    "Parameters": "$n$: length of the input data set",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(n)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Signal Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 43,
    "Family Name": "Line Drawing",
    "Variation": "Line Drawing",
    "Alias": "Single Line Drawing",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a line segment with endpoints $(x_0, y_0), (x_1, y_1)$ and a discrete graphical medium (like pixel-based displays and printers), draw/approximate the line segment on the medium, potentially with antialiasing.",
    "Description Reference": "http://www.cs.gettysburg.edu/~ilinkin/courses/Fall-2014/cs373/handouts/papers/gs-fegsd-81.pdf",
    "Parameters": "$n$: number of pixels the line goes through",
    "Parameter for graphs": "n",
    "Input Size": "O(1)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "(many algorithms, such as this one)",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 44,
    "Family Name": "Polygon Clipping",
    "Variation": "Polygon Clipping with Arbitrary Clipping Polygon",
    "Alias": "",
    "Parents": "",
    "Children": "Polygon Clipping with Convex Clipping Polygon;",
    "Problem Description": "Clipping is an essential part of image synthesis. Traditionally, polygon clipping has been used to clip out the portions of a polygon that lie outside the window of the output device to prevent undesirable effects. In the recent past polygon clipping is used to render 3D images through hidden surface removal and to produce high-quality surface details using techniques such as Beam tracing. Polygon clipping is also used in distributing the objects of a scene to appropriate processors in multiprocessor raytracing systems to improve rendering speeds.",
    "Description Reference": "https://davis.wpi.edu/~matt/courses/clipping/",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 44,
    "Family Name": "Polygon Clipping",
    "Variation": "Polygon Clipping with Convex Clipping Polygon",
    "Alias": "",
    "Parents": "Polygon Clipping with Arbitrary Clipping Polygon",
    "Children": "",
    "Problem Description": "Here, the clipping polygon is restricted to being convex.",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 45,
    "Family Name": "Shown Surface Determination",
    "Variation": "(3-Dimensional, i.e. project onto a 2D plane)",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "This is the process of identifying what surfaces and parts of surfaces can be seen from a particular viewing angle. Given a set of obstacles in the Euclidean space, two points in the space are said to be visible to each other, if the line segment that joins them does not intersect any obstacles.",
    "Description Reference": "https://www.cs.drexel.edu/~david/Classes/Papers/p443-newell.pdf",
    "Parameters": "$n$: number of polygons\n$p$: number of pixels in viewport",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "Omega(n+p)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 46,
    "Family Name": "Line Simplification",
    "Variation": "Line Simplification",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Line simplification is the process of taking a line/curve as represented by a list of points and reducing the number of points needed to accurately represent the given line.",
    "Description Reference": "https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.494.7321",
    "Parameters": "$n$: number of points representing the curve/line initially",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 47,
    "Family Name": "Eigenvalues (Iterative Methods)",
    "Variation": "All Eigenvalues",
    "Alias": "",
    "Parents": "Any Eigenvalue",
    "Children": "",
    "Problem Description": "Given an $n \\times n$ matrix $A$, find all eigenvalues of $A$.",
    "Description Reference": "https://mathworld.wolfram.com/Eigenvalue.html#:~:text=Eigenvalues%20are%20a%20special%20set,Marcus%20and%20Minc%201988,%20p.",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 47,
    "Family Name": "Eigenvalues (Iterative Methods)",
    "Variation": "Any Eigenvalue",
    "Alias": "",
    "Parents": "Any Eigenpair",
    "Children": "All Eigenvalues;",
    "Problem Description": "Given an $n \\times n$ matrix $A$, find any eigenvalue of $A$.",
    "Description Reference": "https://mathworld.wolfram.com/Eigenvalue.html#:~:text=Eigenvalues%20are%20a%20special%20set,Marcus%20and%20Minc%201988,%20p.",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 47,
    "Family Name": "Eigenvalues (Iterative Methods)",
    "Variation": "All Eigenpairs",
    "Alias": "",
    "Parents": "Any Eigenpair",
    "Children": "",
    "Problem Description": "Given an $n \\times n$ matrix $A$, find all eigenpairs (eigenvalues and associated eigenvectors) of $A$.",
    "Description Reference": "https://mathworld.wolfram.com/Eigenvalue.html#:~:text=Eigenvalues%20are%20a%20special%20set,Marcus%20and%20Minc%201988,%20p.",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n^2)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 47,
    "Family Name": "Eigenvalues (Iterative Methods)",
    "Variation": "Any Eigenpair",
    "Alias": "",
    "Parents": "",
    "Children": "Any Eigenvalue; All Eigenpairs; Eigenpair with the Largest Eigenvalue; Eigenpair closest to mu;",
    "Problem Description": "Given an $n \\times n$ matrix $A$, find any eigenpair (eigenvalue and associated eigenvector) of $A$.",
    "Description Reference": "https://mathworld.wolfram.com/Eigenvalue.html#:~:text=Eigenvalues%20are%20a%20special%20set,Marcus%20and%20Minc%201988,%20p.",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 47,
    "Family Name": "Eigenvalues (Iterative Methods)",
    "Variation": "Eigenpair with the Largest Eigenvalue",
    "Alias": "",
    "Parents": "Any Eigenpair",
    "Children": "",
    "Problem Description": "Given an $n \\times n$ matrix $A$, find the eigenpair (eigenvalue and associated eigenvector) of $A$ with the largest eigenvalue.",
    "Description Reference": "https://mathworld.wolfram.com/Eigenvalue.html#:~:text=Eigenvalues%20are%20a%20special%20set,Marcus%20and%20Minc%201988,%20p.",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 47,
    "Family Name": "Eigenvalues (Iterative Methods)",
    "Variation": "Eigenpair closest to mu",
    "Alias": "",
    "Parents": "Any Eigenpair",
    "Children": "",
    "Problem Description": "Given an $n \\times n$ matrix $A$, find the eigenpair (eigenvalue and associated eigenvector) of $A$ with the eigenvalue closest to $\\mu$.",
    "Description Reference": "https://mathworld.wolfram.com/Eigenvalue.html#:~:text=Eigenvalues%20are%20a%20special%20set,Marcus%20and%20Minc%201988,%20p.",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 47,
    "Family Name": "Eigenvalues (Iterative Methods)",
    "Variation": "Symmetric Eigenvalue",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 47,
    "Family Name": "Eigenvalues (Iterative Methods)",
    "Variation": "Nonsymmetric Eigenvalue",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 48,
    "Family Name": "Root Computation",
    "Variation": "General Root Computation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a real continuous function, compute one of the roots.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1084580",
    "Parameters": "$\\epsilon$: (additive) tolerance error\n$a, b$: endpoint values, with $b>a$\n$n_{max}$: maximum number of iterations",
    "Parameter for graphs": "n_max",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 48,
    "Family Name": "Root Computation",
    "Variation": "General Root Computation, All Roots",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a real continuous function, compute all of the roots.",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 48,
    "Family Name": "Root Computation",
    "Variation": "Root Computation with continuous first derivative",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a real function with continuous first derivative, compute one of the roots.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1084580",
    "Parameters": "$\\epsilon$: (additive) tolerance error\n$a, b$: endpoint values, with $b>a$\n$n_{max}$: maximum number of iterations",
    "Parameter for graphs": "n_max",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 49,
    "Family Name": "Nearest Neighbor Search",
    "Variation": "k Nearest Neighbors Search",
    "Alias": "k-NNS",
    "Parents": "",
    "Children": "k Approximate Nearest Neighbors Search;",
    "Problem Description": "Within a dataset of $n$ points, find the $k$ closest points to a specified point.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/355744.355745",
    "Parameters": "$n$: number of points in dataset\n$k$: number of neighbors to find",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 49,
    "Family Name": "Nearest Neighbor Search",
    "Variation": "All k Nearest Neighbors Search",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Within a dataset of $n$ points, find the $k$ closest points to all points.",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 49,
    "Family Name": "Nearest Neighbor Search",
    "Variation": "All Nearest Neighbors Search",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Within a dataset of $n$ points, find the closest point to all points (k=1).",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 49,
    "Family Name": "Nearest Neighbor Search",
    "Variation": "k Approximate Nearest Neighbors Search",
    "Alias": "k-ANNS",
    "Parents": "k Nearest Neighbors Search",
    "Children": "k-ANNS for a dense 3D map of geometric points;",
    "Problem Description": "Within a dataset of $n$ points, find approximately the $k$ closest points to a specified point.",
    "Description Reference": "https://ieeexplore.ieee.org/document/8594636",
    "Parameters": "$n$: number of points in dataset\n$k$: number of neighbors to find",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 49,
    "Family Name": "Nearest Neighbor Search",
    "Variation": "k-ANNS for a dense 3D map of geometric points",
    "Alias": "",
    "Parents": "k Approximate Nearest Neighbors Search",
    "Children": "",
    "Problem Description": "Within a dataset of $n$ points in a dense 3D geometric map, find approximately the $k$ closest points to a specified point.",
    "Description Reference": "https://ieeexplore.ieee.org/document/8594636",
    "Parameters": "$n$: number of points in dataset\n$k$: number of neighbors to find",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 50,
    "Family Name": "Coset Enumeration",
    "Variation": "Coset Enumeration",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Coset enumeration programs implement systematic procedures for enumerating the cosets of a subgroup H of finite index in a group G, given a set of defining relations for G and words generating H.",
    "Description Reference": "https://arxiv.org/pdf/math/9406202.pdf",
    "Parameters": "$n$: number of generators\n$g$: order of group (possibly exponential in $n$)\n$k$: number of relations\n$c$: maximum number of generators multiplied together in a relation",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 51,
    "Family Name": "Maximum Likelihood Parameters",
    "Variation": "Maximum Likelihood Parameters",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In these algorithms, the goal is to estimate hyperparameters using maximum likelihood.",
    "Description Reference": "https://www.jstor.org/stable/2984875",
    "Parameters": "$n$: number of observations in sample\n$r$: number of parameters + latent variables",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(r)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 52,
    "Family Name": "Cardinality Estimation",
    "Variation": "Cardinality Estimation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a multiset of (possibly hashed) values, estimate the number of distinct elements of the multiset. Of interest is minimizing storage usage.",
    "Description Reference": "http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf",
    "Parameters": "$N$: number of values in multiset\n$n$: cardinality of multiset (not known)",
    "Parameter for graphs": "N",
    "Input Size": "O(N)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "https://oertl.github.io/hyperloglog-sketch-estimation-paper/paper/paper.pdf",
    "__1": "https://www.vldb.org/pvldb/vol11/p499-harmouch.pdf",
    "__2": "<= see these for more algos?",
    "__3": ""
  },
  {
    "Old Family #": 53,
    "Family Name": "Register Allocation",
    "Variation": "Local Register Allocation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Register allocation is the process of mapping the unlimited number of symbolic registers assumed in the intermediate language into the limited real machine registers.\n\nLocal register allocation deals with the allocation of registers in straight-line code segments (http://www.cs.ucr.edu/~gupta/research/Publications/Comp/p370-gupta.pdf).",
    "Description Reference": "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.452.8606&rep=rep1&type=pdf",
    "Parameters": "$n$: number of live ranges (the number of candidates to reside in registers)",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 53,
    "Family Name": "Register Allocation",
    "Variation": "Global Register Allocation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Register allocation is the process of mapping the unlimited number of symbolic registers assumed in the intermediate language into the limited real machine registers.\n\nGlobal register allocation deals with the allocation of registers in code containing branches (http://www.cs.ucr.edu/~gupta/research/Publications/Comp/p370-gupta.pdf).",
    "Description Reference": "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.452.8606&rep=rep1&type=pdf",
    "Parameters": "$n$: number of live ranges (the number of candidates to reside in registers)",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "NP-Complete",
    "Lower Bound Reference": "http://www.cs.ucr.edu/~gupta/research/Publications/Comp/p370-gupta.pdf",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 54,
    "Family Name": "Voronoi Diagrams",
    "Variation": "Voronoi Diagrams",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of $n$ points in 2-dimensional space, compute the Voronoi diagram with the $n$ points as seeds.",
    "Description Reference": "https://www.wias-berlin.de/people/si/course/files/Fortune87-SweepLine-Voronoi.pdf",
    "Parameters": "$n$: number of points",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n*log(n))",
    "Upper Bound Reference": "Fortune's algorithm",
    "Best Known Lower Bound": "Omega(n*log(n))",
    "Lower Bound Reference": "Reduction from sorting",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 54,
    "Family Name": "Voronoi Diagrams",
    "Variation": "Constuct Voronoi Diagram",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 55,
    "Family Name": "Variance Calculations",
    "Variation": "Variance Calculations",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of n (real/integer) numbers, compute the variance (sample or population). Of interest is streaming algorithms and numerical stability.",
    "Description Reference": "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.302.7503&rep=rep1&type=pdf",
    "Parameters": "$n$: number of values",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "(many algorithms)",
    "Best Known Lower Bound": "Omega(n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 56,
    "Family Name": "Topological Sorting",
    "Variation": "Topological Sorting",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a graph or network, find a topological sorting of the graph. A list in topological order has a special property. Simply expressed: proceeding from element to element along any path in the network, one passes through the list in one direction only. Stated another way, a list in topological order is such that no element appears in it until after all elements appearing on all paths leading to the particular element have been listed.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/368996.369025",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 57,
    "Family Name": "DFA Minimization",
    "Variation": "DFA Minimization",
    "Alias": "",
    "Parents": "",
    "Children": "Acyclic DFA Minimization; Cyclic Nontrivial SCCs DFA Minimization;",
    "Problem Description": "Given a finite deterministic automaton (DFA) from a class $C$ of DFAs, determine its minimal automaton given by the equivalence relation on states.",
    "Description Reference": "https://www.labri.fr/perso/zeitoun/research/pdf/Almeida-Zeitoun-IPL2008.pdf",
    "Parameters": "$n$: number of states\n$d$: number of transitions\n$k$: size of alphabet",
    "Parameter for graphs": "n",
    "Input Size": "O(n + d)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 57,
    "Family Name": "DFA Minimization",
    "Variation": "Acyclic DFA Minimization",
    "Alias": "",
    "Parents": "DFA Minimization",
    "Children": "",
    "Problem Description": "Given an acyclic finite deterministic automaton (DFA) from a class $C$ of DFAs, determine its minimal automaton given by the equivalence relation on states.",
    "Description Reference": "https://www.labri.fr/perso/zeitoun/research/pdf/Almeida-Zeitoun-IPL2008.pdf",
    "Parameters": "$n$: number of states\n$d$: number of transitions\n$k$: size of alphabet",
    "Parameter for graphs": "n",
    "Input Size": "O(n + d)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 57,
    "Family Name": "DFA Minimization",
    "Variation": "Cyclic Nontrivial SCCs DFA Minimization",
    "Alias": "",
    "Parents": "DFA Minimization",
    "Children": "",
    "Problem Description": "Given an finite deterministic automaton (DFA) from a class $C$ of DFAs, whose nontrivial SCCs are cyclic, determine its minimal automaton given by the equivalence relation on states.",
    "Description Reference": "https://www.labri.fr/perso/zeitoun/research/pdf/Almeida-Zeitoun-IPL2008.pdf",
    "Parameters": "$n$: number of states\n$d$: number of transitions\n$k$: size of alphabet",
    "Parameter for graphs": "n",
    "Input Size": "O(n + d)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 58,
    "Family Name": "Lowest Common Ancestor",
    "Variation": "Lowest Common Ancestor",
    "Alias": "Nearest Common Ancestor",
    "Parents": "",
    "Children": "Off-Line Lowest Common Ancestor; Lowest Common Ancestor with Static Trees; Lowest Common Ancestor with Linking Roots; Lowest Common Ancestor with Linking; Lowest Common Ancestors with Linking and Cutting;",
    "Problem Description": "Given a collection of rooted trees, answer queries of the form, \"What is the nearest\ncommon ancestor of vertices $x$ and $y$?",
    "Description Reference": "https://www.semanticscholar.org/paper/Fast-Algorithms-for-Finding-Nearest-Common-Harel-Tarjan/8867d059dda279b1aed4a0301e4e46f9daf65174",
    "Parameters": "$n$: number of vertices\n$m$: number of total number of operations (queries, links, and cuts)",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(m)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 58,
    "Family Name": "Lowest Common Ancestor",
    "Variation": "Off-Line Lowest Common Ancestor",
    "Alias": "",
    "Parents": "Lowest Common Ancestor",
    "Children": "",
    "Problem Description": "Given a collection of rooted trees, answer queries of the form, \"What is the nearest\ncommon ancestor of vertices $x$ and $y$?\" In this version of the problem, the collection of trees is static and the entire sequence of queries is specified in advance.",
    "Description Reference": "https://www.semanticscholar.org/paper/Fast-Algorithms-for-Finding-Nearest-Common-Harel-Tarjan/8867d059dda279b1aed4a0301e4e46f9daf65174",
    "Parameters": "$n$: number of vertices\n$m$: number of total number of operations (queries, links, and cuts)",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(m)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 58,
    "Family Name": "Lowest Common Ancestor",
    "Variation": "Lowest Common Ancestor with Static Trees",
    "Alias": "",
    "Parents": "Lowest Common Ancestor",
    "Children": "",
    "Problem Description": "Given a collection of rooted trees, answer queries of the form, \"What is the nearest\ncommon ancestor of vertices $x$ and $y$?\" In this version of the problem, the collection of trees is static but the queries are given on-line. That is, each query must be answered before the next one is known.",
    "Description Reference": "https://www.semanticscholar.org/paper/Fast-Algorithms-for-Finding-Nearest-Common-Harel-Tarjan/8867d059dda279b1aed4a0301e4e46f9daf65174",
    "Parameters": "$n$: number of vertices\n$m$: number of total number of operations (queries, links, and cuts)",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(m)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 58,
    "Family Name": "Lowest Common Ancestor",
    "Variation": "Lowest Common Ancestors for vertex pairs of a directed tree",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 58,
    "Family Name": "Lowest Common Ancestor",
    "Variation": "Lowest Common Ancestors with insertion and deletion of leaves",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 58,
    "Family Name": "Lowest Common Ancestor",
    "Variation": "Lowest Common Ancestor with Linking Roots",
    "Alias": "",
    "Parents": "Lowest Common Ancestor",
    "Children": "",
    "Problem Description": "Given a collection of rooted trees, answer queries of the form, \"What is the nearest\ncommon ancestor of vertices $x$ and $y$?\" In this version of the problem, The queries are given on-line. Interspersed with the queries are on-line commands of the form $link(x, y)$ where $x$ and $y$ are tree roots. The effect of a command $link(x, y)$ is to combine the trees containing $x$ and $y$ by making $x$ the parent of $y$.",
    "Description Reference": "https://www.semanticscholar.org/paper/Fast-Algorithms-for-Finding-Nearest-Common-Harel-Tarjan/8867d059dda279b1aed4a0301e4e46f9daf65174",
    "Parameters": "$n$: number of vertices\n$m$: number of total number of operations (queries, links, and cuts)",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(m)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 58,
    "Family Name": "Lowest Common Ancestor",
    "Variation": "Lowest Common Ancestor with Linking",
    "Alias": "",
    "Parents": "Lowest Common Ancestor",
    "Children": "",
    "Problem Description": "Given a collection of rooted trees, answer queries of the form, \"What is the nearest\ncommon ancestor of vertices $x$ and $y$?\" In this version of the problem, the queries are on-line. Interspersed with the queries are on-line commands $link(x, y)$ such that $y$, but not necessarily $x$, is a tree root. The effect of a command $link(x, y)$ is to combine the trees containing $x$ and $y$ by making $x$ the parent of $y$.",
    "Description Reference": "https://www.semanticscholar.org/paper/Fast-Algorithms-for-Finding-Nearest-Common-Harel-Tarjan/8867d059dda279b1aed4a0301e4e46f9daf65174",
    "Parameters": "$n$: number of vertices\n$m$: number of total number of operations (queries, links, and cuts)",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(m)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 58,
    "Family Name": "Lowest Common Ancestor",
    "Variation": "Lowest Common Ancestors with Linking and Cutting",
    "Alias": "",
    "Parents": "Lowest Common Ancestor",
    "Children": "",
    "Problem Description": "Given a collection of rooted trees, answer queries of the form, \"What is the nearest\ncommon ancestor of vertices $x$ and $y$?\" In this version of the problem, the queries are on-line. Interspersed with the queries are on-line commands of two types: $link(x, y)$, where $y$ but not necessarily $x$ is a tree root, and $cut (x)$, where $x$ is not a root. The effect of a command $link(x, y)$ is to combine the trees containing $x$ and $y$ by making $x$ the parent of $y$. The effect of a command $cut (x)$ is to cut the edge connecting $x$ and its parent, splitting the tree containing $x$ into two trees: one containing all descendants of $x$ and another containing all nondescendants of $x$.",
    "Description Reference": "https://www.semanticscholar.org/paper/Fast-Algorithms-for-Finding-Nearest-Common-Harel-Tarjan/8867d059dda279b1aed4a0301e4e46f9daf65174",
    "Parameters": "$n$: number of vertices\n$m$: number of total number of operations (queries, links, and cuts)",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(m)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 59,
    "Family Name": "Graph Edit Distance Computation",
    "Variation": "Exact GED",
    "Alias": "GED Computation",
    "Parents": "",
    "Children": "",
    "Problem Description": "The GED of two graphs is defined as the minimum cost of an edit path between them, where an edit path is a sequence of edit operations (inserting, deleting, and relabeling vertices or edges) that transforms one graph into another. Exact GED computes the GED exactly.",
    "Description Reference": "https://www.sciencedirect.com/science/article/am/pii/S095070511830488X",
    "Parameters": "$V$: number of vertices in the larger of the two graphs",
    "Parameter for graphs": "V",
    "Input Size": "O(V)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "exp(V)",
    "Lower Bound Reference": "NP-Hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 59,
    "Family Name": "Graph Edit Distance Computation",
    "Variation": "Inexact GED",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The GED of two graphs is defined as the minimum cost of an edit path between them, where an edit path is a sequence of edit operations (inserting, deleting, and relabeling vertices or edges) that transforms one graph into another. Inexact GED computes an answer that is not gauranteed to be the exact GED.",
    "Description Reference": "https://www.sciencedirect.com/science/article/am/pii/S095070511830488X",
    "Parameters": "$V$: number of vertices in the larger of the two graphs",
    "Parameter for graphs": "V",
    "Input Size": "O(V)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 60,
    "Family Name": "Clique Problems",
    "Variation": "Enumerating Maximal Cliques, arbitrary graph",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "A maximal clique (complete subgraph) is a clique that is not contained in any other clique. The goal here is to enumerate such maximal cliques in a given graph.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/362342.362367",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(3^(n/3))",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 60.1,
    "Family Name": "Clique Problems",
    "Variation": "k-Clique",
    "Alias": "",
    "Parents": "",
    "Children": "Exact k-Clique; Min-Weight k-Clique; Max-Weight k-Clique;",
    "Problem Description": "For a constant $k \\geq 3$, the $k$-Clique problem is as follows: given a graph $G = (V, E)$ on $n$ vertices, does $G$ contain $k$ distinct vertices $a_1, \\ldots, a_k$ so that for every $(i, j)$, $i \\neq j$, $(a_i, a_j ) \\in E$? Such a $k$ node graph is called a $k$-clique.",
    "Description Reference": "https://people.csail.mit.edu/virgi/eccentri.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: size of clique",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "O(n^(k-(3-omega)*floor(k/3)) where omega is the exponent on matrix multiplication",
    "Upper Bound Reference": "https://dml.cz/bitstream/handle/10338.dmlcz/106381/CommentatMathUnivCarol_026-1985-2_22.pdf",
    "Best Known Lower Bound": "$\\Omega(n^{\\omega k / 3 - \\epsilon})$ for all $\\epsilon > 0$",
    "Lower Bound Reference": "k-Clique Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 60.1,
    "Family Name": "Clique Problems",
    "Variation": "Enumerating k-Cliques",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "enumerates all $k$-Cliques in given graph",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 60.2,
    "Family Name": "Clique Problems",
    "Variation": "Exact k-Clique",
    "Alias": "",
    "Parents": "k-Clique",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, find a $k$-clique of weight 0.",
    "Description Reference": "https://people.csail.mit.edu/virgi/eccentri.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: size of clique",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "$\\Omega(n^{k-o(1)})$",
    "Lower Bound Reference": "Exact k-Clique Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 60.3,
    "Family Name": "Clique Problems",
    "Variation": "Min-Weight k-Clique",
    "Alias": "",
    "Parents": "k-Clique",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, find the $k$-clique of minimum weight.",
    "Description Reference": "https://people.csail.mit.edu/virgi/eccentri.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: size of clique",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "$\\Omega(n^{k-o(1)})$",
    "Lower Bound Reference": "Min-Weight k-Clique Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 60.4,
    "Family Name": "Clique Problems",
    "Variation": "Max-Weight k-Clique",
    "Alias": "",
    "Parents": "k-Clique",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, find the $k$-clique of maximum weight.",
    "Description Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: size of clique",
    "Parameter for graphs": "n",
    "Input Size": "O(m+n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "$\\Omega(n^{k-o(1)})$",
    "Lower Bound Reference": "Min-Weight k-Clique Hypothesis, negate weights",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 60.4,
    "Family Name": "Clique Problems",
    "Variation": "Max-Weight Clique",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, find the clique of maximum weight. $k$ is not given",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 61,
    "Family Name": "The Traveling-Salesman Problem",
    "Variation": "Minimum TSP",
    "Alias": "TSP",
    "Parents": "",
    "Children": "",
    "Problem Description": "In Minimum TSP, you are given a set $C$ of cities and distances between each distinct pair of cities. The goal is to find an ordering or tour of the cities, such that you visit each city exactly once and return to the origin city, that minimizes the length of the tour. This is the typical variation of TSP.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/876638.876640",
    "Parameters": "$V$: number of cities (nodes)\n$E$: number of roads (edges)",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "O(V^2 2^V)",
    "Upper Bound Reference": "Algo #484",
    "Best Known Lower Bound": "\\Omega(\\poly(V))",
    "Lower Bound Reference": "Karp 1972",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 61,
    "Family Name": "The Traveling-Salesman Problem",
    "Variation": "Maximum TSP",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In Maximum TSP, you are given a set $C$ of cities and distances between each distinct pair of cities. The goal is to find an ordering or tour of the cities, such that you visit each city exactly once and return to the origin city, that maximizes the length of the tour.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/876638.876640",
    "Parameters": "$V$: number of cities (nodes)\n$E$: number of roads (edges)",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(V))",
    "Lower Bound Reference": "https://dl.acm.org/doi/pdf/10.1145/876638.876640",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 61,
    "Family Name": "The Traveling-Salesman Problem",
    "Variation": "Approximate TSP",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Approximate TSP is the problem of finding an approximate answer to Minimum TSP.\n\nIn Minimum TSP, you are given a set $C$ of cities and distances between each distinct pair of cities. The goal is to find an ordering or tour of the cities, such that you visit each city exactly once and return to the origin city, that minimizes the length of the tour. This is the typical variation of TSP.",
    "Description Reference": "https://link.springer.com/chapter/10.1007/978-1-4020-9688-4_3",
    "Parameters": "$V$: number of cities (nodes)\n$E$: number of roads (edges)",
    "Parameter for graphs": "V",
    "Input Size": "O(V+E)",
    "Output Size": "O(V)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 62,
    "Family Name": "Poisson Problem",
    "Variation": "2-Dimensional Poisson Problem",
    "Alias": "Two-dimensional elliptic partial differential equations",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given $f$, solve for $u$ in the 2-dimensional Poisson equation:\n\n$u_{xx} + u_{yy} = f(x,y)$",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/1053379.1053381",
    "Parameters": "$n$: dimension of grid (where grid is discretized)",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "Better version: https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1117&context=cstech",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 63,
    "Family Name": "Poisson Problem",
    "Variation": "3-Dimensional Poisson Problem",
    "Alias": "Three-dimensional elliptic partial differential equations",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given $f$, solve for $u$ in the 3-dimensional Poisson equation:\n\n$u_{xx} + u_{yy} + u_{zz} = f(x,y,z)$",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/1053379.1053381",
    "Parameters": "$n$: dimension of grid (where grid is discretized)",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 64,
    "Family Name": "Delaunay Triangulation",
    "Variation": "Delaunay Triangulation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of points, the Delaunay Triangulation problem is to triangulate the points using the following notion of triangulation.\n\n$AB$ is an edge of the Delaunay triangulation iff there is a circle passing through $A$ and $B$ so that all other points in the point set, $C$, where $C$ is not equal to $A$ or $B$, lie outside the circle. Equivalently, all triangles in the Delaunay triangulation for a set of points will have empty circumscribed circles. That is, no points lie in the interior of any triangle's circumcircle.",
    "Description Reference": "http://www.geom.uiuc.edu/~samuelp/del_project.html",
    "Parameters": "$n$: number of points",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 64,
    "Family Name": "Delaunay Triangulation",
    "Variation": "2-Dimensional Delaunay Triangulation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 64,
    "Family Name": "Delaunay Triangulation",
    "Variation": "3-Dimensional Delaunay Triangulation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 64,
    "Family Name": "Delaunay Triangulation",
    "Variation": "d-Dimensional Delaunay Triangulation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 64,
    "Family Name": "Delaunay Triangulation",
    "Variation": "Spherical Delaunay Triangulation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 65,
    "Family Name": "De Novo Genome Assembly",
    "Variation": "De Novo Genome Assembly",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "De novo sequencing refers to sequencing a novel genome where there is no reference sequence available for alignment. Sequence reads are assembled as contigs, and the coverage quality of de novo sequence data depends on the size and continuity of the contigs (ie, the number of gaps in the data).",
    "Description Reference": "https://www.illumina.com/techniques/sequencing/dna-sequencing/whole-genome-sequencing/de-novo-sequencing.html",
    "Parameters": "$n$: sum of lengths of reads\n$f$: number of input sequences",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Bioinformatics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 66,
    "Family Name": "The Subset-Sum Problem",
    "Variation": "Subset Sum",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set $S$ of integers and a target sum $t$, determine whether there is a subset of $S$ that sum to $t$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3329863",
    "Parameters": "$S$: the set of integers\n$n$: the number of integers in the set\n$n'$: the number of distinct elements in the set\n$t$: the target sum\n$\\sigma$: sum of elements in the set",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "\\tilde{O}(min{\\sqrt{n'}t, t^{5/4}, σ})",
    "Upper Bound Reference": "Algo #544",
    "Best Known Lower Bound": "\\Omega(t^{1-\\epsilon} 2^{o(n)})",
    "Lower Bound Reference": "Reduction #136",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 67,
    "Family Name": "Dependency Inference Problem",
    "Variation": "Functional Dependency Inference Problem",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The functional dependency inference problem is to find a cover for the set of functional dependencies that hold in a given relation.\n\nA functional dependency (abbr. FD), $f$, is a statement $f: X \\rightarrow Y$ where $X$ and $Y$ are sets of attributes. If $R(X, Y, \\ldots)$ is a relation on a set of attributes that contains $X$ and $Y$, then $R$ obeys the FD $f$ if every two tuples of $R$ which have the same projection on $X$ also have the same projection on $Y$. Given $f: X \\rightarrow Y$, we say that $f$ is a functional dependency from $X$ to $Y$, that $Y$ is functionally dependent on $X$ or that $X$ functionally determines $Y$. From the definition it follows that for each pair of sets $X$ and $Y$ there is at most one functional dependency from $X$ to $Y$. Therefore, we usually omit the name of the FD and write $X \\rightarrow Y$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/509404.509414",
    "Parameters": "$n$: number of attributes\n$p$: number of tuples/rows/data points",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n)",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/0166218X92900315",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Databases",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 70,
    "Family Name": "Dependency Inference Problem",
    "Variation": "Multivalued Dependency Inference Problem",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The multivalued dependency inference problem is to find a cover for the set of multivalued dependencies that hold in a given relation.\n\nA multivalued dependency (abbr. MVD), $g$, on a set of attributes $U$ is a statement $g: X \\rightarrow \\rightarrow Y$, where $X$ and $Y$ are subsets of $U$. Let $Z$ be the complement of the union of $X$ and $Y$ in $U$. A relation $R(U)$ obeys the MVD $g: X \\rightarrow \\rightarrow Y$ if for every $XZ$-value, $xz$, that appears in $R$, we have $Y_R(xz) = Y_R (x)$. In words, the MVD $g$ is valid in $R$ if the set of $Y$-values that appears in $R$ with a given $x$ appears with every combination of $x$ and $z$ in $R$. Thus, this set is a function of $x$ alone and does not depend on the $Z$-values that appear with $x$. Given $g: X \\rightarrow \\rightarrow Y$, we say that $g$ is a multivalued dependency from $X$ to $Y$ (in the set $U$). As we do for functional dependencies (FD's), here also we usually omit the name $g$ of the MVD and just write $X \\rightarrow \\rightarrow Y$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/509404.509414",
    "Parameters": "$n$: number of attributes\n$p$: number of tuples/rows/data points",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(kn^2)",
    "Upper Bound Reference": "https://doi.org/10.1016/0950-5849(92)90028-N",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Databases",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 68,
    "Family Name": "BCNF Decomposition",
    "Variation": "BCNF Decomposition",
    "Alias": "Boyce-Codd Normal Form Decomposition",
    "Parents": "",
    "Children": "",
    "Problem Description": "BCNF Decomposition is the problem of decomposing a relation schema into Boyce-Codd normal form (BCNF).\n\nA relation schema $R$ is in Boyce Codd Normal Form (abbr. BCNF) if for all non-trivial FDs $X \\rightarrow Y$ in $F^+$, $X$ is a superkey. In extending this notion to database schemas, we must be conscious of the UR-assumption. We say that $R_i = <ATTR_i,F_i>$ is in BCNF if the schema $<ATTR_i, F^+[ATTR_i]>$ is in BCNF, and $D$ is in BCNF if each $R_i$ is.",
    "Description Reference": "https://www.microsoft.com/en-us/research/uploads/prod/2020/12/WhatDoesBCNFdo-VLDB1980.pdf",
    "Parameters": "$n$: size of database?\n$k$: number of functional dependencies",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n)",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Databases",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 68,
    "Family Name": "BCNF Decomposition",
    "Variation": "Decisional BCNF",
    "Alias": "Decisional Boyce-Codd Normal Form",
    "Parents": "",
    "Children": "",
    "Problem Description": "Decisional BCNF is the problem of deciding whether or not a relation schema can be turned into Boyce-Codd normal form (BCNF).\n\nA relation schema $R$ is in Boyce Codd Normal Form (abbr. BCNF) if for all non-trivial FDs $X \\rightarrow Y$ in $F^+$, $X$ is a superkey. In extending this notion to database schemas, we must be conscious of the UR-assumption. We say that $R_i = <ATTR_i,F_i>$ is in BCNF if the schema $<ATTR_i, F^+[ATTR_i]>$ is in BCNF, and $D$ is in BCNF if each $R_i$ is.",
    "Description Reference": "https://www.microsoft.com/en-us/research/uploads/prod/2020/12/WhatDoesBCNFdo-VLDB1980.pdf",
    "Parameters": "$n$: size of database?\n$k$: number of functional dependencies",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "NP-hard",
    "Lower Bound Reference": "https://dl.acm.org/doi/pdf/10.1145/990511.990513",
    "Domain": "Databases",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 69,
    "Family Name": "4NF Decomposition",
    "Variation": "4NF Decomposition",
    "Alias": "Fourth Normal Form Decomposition",
    "Parents": "",
    "Children": "4NF Decomposition for Functional and Multivalued Dependency Sets; 4NF Decomposition for Conflict-Free Dependency Sets;",
    "Problem Description": "4NF Decomposition is the problem of decomposing a relation schema into fourth normal form (4NF).\n\nA relation schema $R^*$ is in fourth normal form (4NF) if, whenever a nontrivial multivalued dependency $X \\rightarrow \\rightarrow Y$ holds for $R^*$, then so does the functiunal dependency $X \\rightarrow A$ for every column name $A$ of $R^*$. Intuitively all dependencies are the result of keys. In particular a 4NF relation schema can have no nontrivial multivalued dependencies that are not functional dependencies.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/320557.320571",
    "Parameters": "$n$: size of database?\n$k$: number of functional dependencies",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Databases",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 69,
    "Family Name": "4NF Decomposition",
    "Variation": "4NF Decomposition for Functional and Multivalued Dependency Sets",
    "Alias": "",
    "Parents": "4NF Decomposition",
    "Children": "",
    "Problem Description": "4NF Decomposition is the problem of decomposing a relation schema into fourth normal form (4NF). This variation specifies that the input dependency set has only functional and multivalued dependencies.\n\nA relation schema $R^*$ is in fourth normal form (4NF) if, whenever a nontrivial multivalued dependency $X \\rightarrow \\rightarrow Y$ holds for $R^*$, then so does the functiunal dependency $X \\rightarrow A$ for every column name $A$ of $R^*$. Intuitively all dependencies are the result of keys. In particular a 4NF relation schema can have no nontrivial multivalued dependencies that are not functional dependencies.",
    "Description Reference": "https://www.vldb.org/conf/1983/P186.PDF",
    "Parameters": "$n$: size of database?\n$k$: number of functional dependencies",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 69,
    "Family Name": "4NF Decomposition",
    "Variation": "4NF Decomposition for Conflict-Free Dependency Sets",
    "Alias": "",
    "Parents": "4NF Decomposition",
    "Children": "",
    "Problem Description": "4NF Decomposition is the problem of decomposing a relation schema into fourth normal form (4NF). This variation specifies that the input dependency set is conflict-free.\n\nA relation schema $R^*$ is in fourth normal form (4NF) if, whenever a nontrivial multivalued dependency $X \\rightarrow \\rightarrow Y$ holds for $R^*$, then so does the functiunal dependency $X \\rightarrow A$ for every column name $A$ of $R^*$. Intuitively all dependencies are the result of keys. In particular a 4NF relation schema can have no nontrivial multivalued dependencies that are not functional dependencies.",
    "Description Reference": "https://www.vldb.org/conf/1983/P186.PDF",
    "Parameters": "$n$: size of database?\n$k$: number of functional dependencies",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 71,
    "Family Name": "Disk Scheduling",
    "Variation": "Disk Scheduling",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "When disk requests arrive at the disk device, they are queued for service and a disk scheduling algorithm is used to decide which of a waiting queue of disk requests to serve next.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/98949.99156",
    "Parameters": "$n$: number of requests",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n) for schedule, O(1) for seek distance",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 72,
    "Family Name": "The Vertex Cover Problem",
    "Variation": "The Vertex Cover Problem",
    "Alias": "VC",
    "Parents": "",
    "Children": "The Vertex Cover Problem, Degrees Bounded By 3;",
    "Problem Description": "A vertex cover of a graph $G$ is a set $C$ of vertices such that every edge of $G$ has at least one endpoint in $C$. The vertex cover problem is to find a minimum-size vertex cover in a given graph $G$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/1101821.1101823",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: size of vertex cover",
    "Parameter for graphs": "n",
    "Input Size": "O(m + n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 72,
    "Family Name": "The Vertex Cover Problem",
    "Variation": "The Vertex Cover Problem, Degrees Bounded By 3",
    "Alias": "3DVC",
    "Parents": "The Vertex Cover Problem",
    "Children": "",
    "Problem Description": "A vertex cover of a graph $G$ is a set $C$ of vertices such that every edge of $G$ has at least one endpoint in $C$. The vertex cover problem is to find a minimum-size vertex cover in a given graph $G$. This version of the problem is such that the input graph $G$ has all vertices' degree bounded by 3.",
    "Description Reference": "https://doi.org/10.1002/1097-0037(200007)35:4<253::AID-NET3>3.0.CO;2-K",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: size of vertex cover",
    "Parameter for graphs": "n",
    "Input Size": "O(m + n)",
    "Output Size": "O(k)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 72,
    "Family Name": "The Vertex Cover Problem",
    "Variation": "The Vertex Cover Problem for Two-Terminal Series-Parallel Graphs",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 73,
    "Family Name": "CFG Problems",
    "Variation": "CFG Parsing",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a grammar $G$ and a string $s$, find the parse structure, or analysis, assigned to the string $s$ by the grammar $G$.",
    "Description Reference": "https://arxiv.org/pdf/cs/0112018.pdf",
    "Parameters": "$n$: length of the given string\n$|G|$: size of the grammar",
    "Parameter for graphs": "n",
    "Input Size": "O(n + |G|)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n^3)",
    "Upper Bound Reference": "https://link.springer.com/chapter/10.1007%2F978-3-662-21545-6_18",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 73,
    "Family Name": "CFG Problems",
    "Variation": "CFG Recognition",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a grammar $G$ and a string $s$, determine if the string $s$ can be derived by the grammar $G$.",
    "Description Reference": "https://arxiv.org/pdf/cs/0112018.pdf",
    "Parameters": "$n$: length of the given string\n$|G|$: size of the grammar",
    "Parameter for graphs": "n",
    "Input Size": "O(n + |G|)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "O(n^2.38 * |G|)",
    "Upper Bound Reference": "https://linkinghub.elsevier.com/retrieve/pii/S0022000075800468",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 74,
    "Family Name": "Finding Frequent Itemsets",
    "Variation": "Finding Frequent Itemsets",
    "Alias": "Finding Association Rules",
    "Parents": "",
    "Children": "",
    "Problem Description": "We assume there is a number $s$, called the support threshold. If $I$ is a set of items, the support for $I$ is the number of baskets for which $I$ is a subset. We say $I$ is frequent if its support is $s$ or more",
    "Description Reference": "http://infolab.stanford.edu/~ullman/mmds/ch6.pdf",
    "Parameters": "$n$: total number of transactions (size of database)",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 75,
    "Family Name": "Data Compression",
    "Variation": "Lossy Compression",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The reduction or ideally elimination of redundancies in the original data to result in smaller required storage space is the goal of every compression scheme. There are two categories of data compression: lossy and lossless.\n\nLossy compression is achieved by only discarding the redundancies and out of human perception information and getting rid of those extra bits.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8708945",
    "Parameters": "$n$: number of items in input series of data",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 75,
    "Family Name": "Data Compression",
    "Variation": "Lossless Compression",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The reduction or ideally elimination of redundancies in the original data to result in smaller required storage space is the goal of every compression scheme. There are two categories of data compression: lossy and lossless.\n\nLossless compression is fully information-preserving and fully reversible.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8708945",
    "Parameters": "$n$: number of items in input series of data",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 76,
    "Family Name": "Factorization of Polynomials Over Finite Fields",
    "Variation": "Factorization of Polynomials Over Finite Fields",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Factor a given polynomial over a finite field into a product of irreducible polynomials.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6768643",
    "Parameters": "$n$: degree of polynomial\n$p$: characteristic of finite field",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^2)",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/abs/pii/0020019090901954",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 77,
    "Family Name": "Cryptanalysis of Linear Feedback Shift Registers",
    "Variation": "Cryptanalysis of Linear Feedback Shift Registers",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Find the shortest linear feedback shift register that can generate a given finite sequence of digits.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1054260",
    "Parameters": "$n$: size of input stream",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Cryptography",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 78,
    "Family Name": "Stable Matching Problem",
    "Variation": "Stable Marriage Problem",
    "Alias": "Stable Matching Problem, SMP",
    "Parents": "Stable Roommates Problem",
    "Children": "Almost Stable Marriage Problem; Boolean d-Attribute Stable Matching; Stable Matching Verification; Stable Pair Checking;",
    "Problem Description": "Given $n$ men and $n$ women, where each person has ranked all members of the opposite sex in order of preference, marry the men and women together such that there are no two people of opposite sex who would both rather have each other than their current partners. When there are no such pairs of people, the set of marriages is deemed stable.",
    "Description Reference": "http://www.eecs.harvard.edu/cs286r/courses/fall09/papers/galeshapley.pdf",
    "Parameters": "$n$: number of men and number of women",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n^2)",
    "Upper Bound Reference": "http://www.dcs.gla.ac.uk/~davidm/pubs/7981.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 78,
    "Family Name": "Stable Matching Problem",
    "Variation": "Almost Stable Marriage Problem",
    "Alias": "",
    "Parents": "Stable Marriage Problem",
    "Children": "",
    "Problem Description": "The task in the Almost Stable Marriage Problem is to find a matching that minimises the number of unstable edges, but the matching does not have to be a maximum matching.",
    "Description Reference": "https://arxiv.org/pdf/0812.4893.pdf",
    "Parameters": "$n$: number of men and number of women",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 78,
    "Family Name": "Stable Matching Problem",
    "Variation": "Stable Roommates Problem",
    "Alias": "SRP",
    "Parents": "",
    "Children": "Stable Marriage Problem;",
    "Problem Description": "Given $2n$ participants, each of participant ranks the others in strict order of preference. A matching is a set of $n$ disjoint pairs of participants. A matching $M$ in an instance of SRP is stable if there are no two participants $x$ and $y$, each of whom prefers the other to their partner in $M$. Such a pair is said to block $M$, or to be a blocking pair with respect to $M$.",
    "Description Reference": "https://doi.org/10.1016/0196-6774(85)90033-1",
    "Parameters": "$n$: number of pairs of roommates",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 78,
    "Family Name": "Stable Matching Problem",
    "Variation": "Boolean d-Attribute Stable Matching",
    "Alias": "",
    "Parents": "Stable Marriage Problem",
    "Children": "",
    "Problem Description": "SMP in the d-attribute model. In the d-attribute model, we assume that there are d different attributes (e.g. income, height, sense of humor, etc.) with a fixed, possibly objective, ranking of the men for each attribute. Each woman’s preference list is based on a linear combination of the attributes of the men, where each woman can have different weights for each attribute. Some women may care more about, say, height whereas others care more about sense of humor. Men’s preferences are defined analogously.",
    "Description Reference": "https://arxiv.org/pdf/1510.06452.pdf",
    "Parameters": "$n$: number of men and number of women\n$d$: number of attributes",
    "Parameter for graphs": "n",
    "Input Size": "O(nd)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 78,
    "Family Name": "Stable Matching Problem",
    "Variation": "Stable Matching Verification",
    "Alias": "",
    "Parents": "Stable Marriage Problem",
    "Children": "",
    "Problem Description": "Verify that a given matching is stable, given the preferences",
    "Description Reference": "https://arxiv.org/pdf/1510.06452.pdf",
    "Parameters": "$n$: number of men and number of women",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 78,
    "Family Name": "Stable Matching Problem",
    "Variation": "Stable Pair Checking",
    "Alias": "",
    "Parents": "Stable Marriage Problem",
    "Children": "",
    "Problem Description": "Verify that a given pairing is stable, given the preferences",
    "Description Reference": "https://arxiv.org/pdf/1510.06452.pdf",
    "Parameters": "$n$: number of pairs of roommates",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 79,
    "Family Name": "Longest Path Problem",
    "Variation": "Longest Path on Interval Graphs",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The longest path problem is the problem of finding a path of maximum length in a graph.\n\nA graph $G$ is called interval graph if its vertices can be put in a one-to-one correspondence with a family $F$ of intervals on the real line such that two vertices are adjacent in $G$ if and only if the corresponding intervals intersect; $F$ is called an intersection model for $G$.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/s00453-010-9411-3.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "O(m + n)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 80,
    "Family Name": "Maximum Subarray Problem",
    "Variation": "Maximum Subarray",
    "Alias": "",
    "Parents": "",
    "Children": "1D Maximum Subarray; 2D Maximum Subarray; Maximum Square Subarray;",
    "Problem Description": "Given a $d$-dimensional array $M$ with $n^d$ real-valued entries, find the $d$-dimensional subarray of $M$ which maximizes the sum of the elements it contains.",
    "Description Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Parameters": "$n$: length of array\n$d$: dimensionality of array",
    "Parameter for graphs": "n^d",
    "Input Size": "O(n^d)",
    "Output Size": "O(d)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 80,
    "Family Name": "Maximum Subarray Problem",
    "Variation": "1D Maximum Subarray",
    "Alias": "Maximum Subsequence",
    "Parents": "Maximum Subarray",
    "Children": "",
    "Problem Description": "Given an array $A$ of length $n$, find $i, j$ with $1\\leq i \\leq j \\leq n$ maximizing $\\sum^j_{x=i} A[x]$, that is, find a contiguous subarray of $A$ of maximum sum",
    "Description Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Parameters": "$n$: length of array",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "Kadane's algorithm",
    "Best Known Lower Bound": "O(n)",
    "Lower Bound Reference": "must read all of input",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 80,
    "Family Name": "Maximum Subarray Problem",
    "Variation": "2D Maximum Subarray",
    "Alias": "",
    "Parents": "Maximum Subarray",
    "Children": "",
    "Problem Description": "Given an $n \\times n$ matrix $A$ of integers, find $i, j, k,l \\in [n]$ with $i \\leq j, k \\leq l$ maximizing $\\sum^j_{x=i}\\sum^l_{y=k}A[x,y]$, that is, find a contiguous subarray of $A$ of maximum sum",
    "Description Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Parameters": "$n$: dimension of array",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "O(n^3 * ((log log n)/(log n))^(1/2))",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/S1571066104003135?via%3Dihub",
    "Best Known Lower Bound": "Omega(n^{3-\\epsilon})",
    "Lower Bound Reference": "Reduction from APSP",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 80,
    "Family Name": "Maximum Subarray Problem",
    "Variation": "Maximum Square Subarray",
    "Alias": "",
    "Parents": "Maximum Subarray",
    "Children": "",
    "Problem Description": "Given an $n \\times n$ matrix find a maximum subarray with sides of equal length.",
    "Description Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Parameters": "$n$: dimension of array",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 81,
    "Family Name": "Constructing Suffix Trees",
    "Variation": "Constructing Suffix Trees",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Let $T = t_1 t_2 \\cdots t_n, be a string over an alphabet $\\Sigma$. Each string $x$ such that $T = uxv$ for some (possibly empty) strings $u$ and $v$ is a substring of $T$, and each string $T_i = t_i \\cdots t_n$, where $1 \\leq i \\leq n + 1$ is a suffix of $T$; in particular, $T_{n+1} = \\epsilon$ is the empty suffix. The set of all suffixes of $T$ is denoted $\\sigma(T)$. The suffix trie $STrie(T)$ of $T$ is a trie representing $\\sigma(T)$.\n\nSuffix tree $STree(T)$ of $T$ is a data structure that represents $STrie(T)$ in space linear in the length $|T|$ of $T$. This is achieved by representing only a subset $Q' \\cup \\{ \\perp \\}$ of the states of $STrie(T)$.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF01206331.pdf",
    "Parameters": "$n$: length of string",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 82,
    "Family Name": "Ray Tracing",
    "Variation": "Ray Tracing",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Ray tracing is an image rendering technique in which rays are cast from the viewpoint and followed as they reflect off of objects in the scene.",
    "Description Reference": "https://graphics.stanford.edu/courses/Appel.pdf",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 83,
    "Family Name": "Entity Resolution",
    "Variation": "Entity Resolution",
    "Alias": "ER",
    "Parents": "",
    "Children": "",
    "Problem Description": "Entity resolution (ER) is the problem of matching records that represent the same real-world entity and then merging the matching records. ER is a well known problem that arises in many applications. An exhaustive ER process involves comparing all the pairs of records, which can be very expensive for large datasets.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/1559845.1559870",
    "Parameters": "$n$: number of records\n$k$: number of features",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 84,
    "Family Name": "Longest Palindromic Substring",
    "Variation": "Longest Palindromic Substring",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a string of length $n$, find the palindromic substrings of maximal length.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF01182773.pdf",
    "Parameters": "$n$: length of given string",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "O(n) (if outputting multiple substrings, or if outputting the substrings themselves)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 85,
    "Family Name": "AST to Code Translation",
    "Variation": "AST to Code Translation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Translate a given abstract syntax tree (AST) into machine-readable code that uses as few registers as possible.",
    "Description Reference": "https://hillside.net/plop/plop2003/Papers/Jones-ImplementingASTs.pdf",
    "Parameters": "$n$: number of nodes in the tree",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 85,
    "Family Name": "AST to Code Translation",
    "Variation": "Arithmetic Expression Binary Tree",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Translate a given arithmetic expression binary tree into machine-readable code that uses as few registers as possible.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/236114.236117",
    "Parameters": "$n$: number of nodes in the tree",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 86,
    "Family Name": "Graph Isomorphism Problem",
    "Variation": "Graph Isomorphism, General Graphs",
    "Alias": "",
    "Parents": "",
    "Children": "Graph Isomorphism, Bounded Number of Vertices of Each Color; Graph Isomorphism, Trivalent Graphs; Graph Isomorphism, Bounded Vertex Valences; Largest Common Subtree;",
    "Problem Description": "Given two graphs, determine whether they are isomorphic to one another.",
    "Description Reference": "https://onlinelibrary.wiley.com/doi/pdf/10.1002/jgt.3190010410",
    "Parameters": "$n$: number of vertices in the larger graph",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(1)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 86,
    "Family Name": "Graph Isomorphism Problem",
    "Variation": "Graph Isomorphism, Bounded Number of Vertices of Each Color",
    "Alias": "",
    "Parents": "Graph Isomorphism, General Graphs",
    "Children": "",
    "Problem Description": "Given two colored graphs with the number of vertices of each color bounded, determine whether they are isomorphic to one another.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF02104746.pdf",
    "Parameters": "$n$: number of vertices in the larger graph",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(1)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 86,
    "Family Name": "Graph Isomorphism Problem",
    "Variation": "Graph Isomorphism, Trivalent Graphs",
    "Alias": "",
    "Parents": "Graph Isomorphism, General Graphs",
    "Children": "",
    "Problem Description": "Given two trivalent graphs (AKA cubic graphs--graphs in which each vertex has degree 3), determine whether they are isomorphic to one another.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF02104746.pdf",
    "Parameters": "$n$: number of vertices in the larger graph",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(1)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 86,
    "Family Name": "Graph Isomorphism Problem",
    "Variation": "Graph Isomorphism, Bounded Vertex Valences",
    "Alias": "",
    "Parents": "Graph Isomorphism, General Graphs",
    "Children": "",
    "Problem Description": "Given two graphs with the degree of each vertex bounded, determine whether they are isomorphic to one another.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF02104746.pdf",
    "Parameters": "$n$: number of vertices in the larger graph",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(1)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 86,
    "Family Name": "Graph Isomorphism Problem",
    "Variation": "Largest Common Subtree",
    "Alias": "LCST",
    "Parents": "Graph Isomorphism, General Graphs",
    "Children": "Subtree Isomorphism;",
    "Problem Description": "Find a largest tree which occurs as a common subgraph in a given collection of trees.",
    "Description Reference": "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.4833&rep=rep1&type=pdf",
    "Parameters": "$n$: number of vertices in the largest tree in the collection",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(n)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 86,
    "Family Name": "Graph Isomorphism Problem",
    "Variation": "Subtree Isomorphism",
    "Alias": "",
    "Parents": "Largest Common Subtree",
    "Children": "",
    "Problem Description": "Determine whether a given tree is contained within another tree.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3093239",
    "Parameters": "$n$: number of vertices in the larger graph",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(1)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 87,
    "Family Name": "Graph Realization Problems",
    "Variation": "Digraph Realization Problem",
    "Alias": "",
    "Parents": "",
    "Children": "DAG Realization Problem;",
    "Problem Description": "Given a sequence $S := (a_1, b_1), \\ldots, (a_n, b_n)$ with $a_i, b_i \\in \\mathbb{Z}_0^+$, does there exist a directed graph (no parallel arcs allowed) with labeled vertex set $V := \\{v_1, \\ldots , v_n\\}$ such that for all $v_i \\in V$ indegree and outdegree of $v_i$ match exactly the given numbers $a_i$ and $b_i$, respectively?",
    "Description Reference": "https://arxiv.org/pdf/1203.3636.pdf",
    "Parameters": "$n$: number of degree pairs",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(1)$",
    "Best Known Upper Bound": "$O(VE)$",
    "Upper Bound Reference": "https://linkinghub.elsevier.com/retrieve/pii/0012365X7390037X",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 87,
    "Family Name": "Graph Realization Problems",
    "Variation": "DAG Realization Problem",
    "Alias": "",
    "Parents": "Digraph Realization Problem",
    "Children": "",
    "Problem Description": "Given a sequence $S := (a_1, b_1), \\ldots, (a_n, b_n)$ with $a_i, b_i \\in \\mathbb{Z}_0^+$, does there exist a directed acyclic graph (DAG) (no parallel arcs allowed) with labeled vertex set $V := \\{v_1, \\ldots , v_n\\}$ such that for all $v_i \\in V$ indegree and outdegree of $v_i$ match exactly the given numbers $a_i$ and $b_i$, respectively?",
    "Description Reference": "https://arxiv.org/pdf/1203.3636.pdf",
    "Parameters": "$n$: number of degree pairs",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(1)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "NP-Complete",
    "Lower Bound Reference": "https://link.springer.com/chapter/10.1007/978-3-642-30870-3_29",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 88,
    "Family Name": "Duplicate Elimination",
    "Variation": "Duplicate Elimination",
    "Alias": "Record Linkage; De-Duplication; Instance Identification; Object Identification; Record Matching",
    "Parents": "",
    "Children": "",
    "Problem Description": "SQL does not eliminate duplicates implicitly. It allows to enter duplicate values on columns other than candidate key or if did not specified any keys. If the user wants to eliminate duplicate records, he has to use DISTINCT keyword in the query.\n\nDatabases, therefore, can have duplicate entries. The problem deals with identifying and removing duplicates from a database.",
    "Description Reference": "https://doi.org/10.1109/ICMV.2009.43",
    "Parameters": "$n$: number of records",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(n)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Databases",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 89,
    "Family Name": "Hyperbolic Spline Interpolation",
    "Variation": "Hyperbolic Spline Interpolation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The problem of restoring complex curves and surfaces from discrete data so that their shape is preserved is called isogeometric interpolation. A very popular tool for solving this problem are hyperbolic splines in tension, which were introduced in 1966 by Schweikert. These splines have smoothness sufficient for many applications; combined with algorithms for the automatic selection of the tension parameters, they adapt well to the given data. Unfortunately, the evaluation of hyperbolic splines is a very difficult problem because of roundoff errors (for small values of the tension parameters) and overflows (for large values of these parameters).\u0000",
    "Description Reference": "https://link.springer.com/content/pdf/10.1134/S0965542511050095.pdf",
    "Parameters": "$n$: number of points",
    "Parameter for graphs": "n",
    "Input Size": "$O(n)$",
    "Output Size": "$O(n)$",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 90,
    "Family Name": "Mesh Parameterization",
    "Variation": "Mesh Parameterization",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given any two surfaces with similar topology it is possible to compute a one-to-one and onto mapping between them. If one of these surfaces is represented by a triangular mesh, the problem of computing such a mapping is referred to as mesh parameterization.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/1236246.1236287",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 91,
    "Family Name": "Maximum Likelihood Methods in Unknown Latent Variables",
    "Variation": "Maximum Likelihood Methods in Unknown Latent Variables",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In this problem, the goal is to compute maximum-likelihood estimates when the observations can be viewed as incomplete data.",
    "Description Reference": "https://www.jstor.org/stable/2984875#metadata_info_tab_contents",
    "Parameters": "$n$: number of observations in sample\n$r$: number of parameters + latent variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Statistics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 92,
    "Family Name": "Collaborative Filtering",
    "Variation": "Matrix Factorization",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Collaborative filtering is a technique used in recommendation systems. It analyzes relationships between users and interdependencies among products to identify new user-item associations.\n\nA method of collaborative filtering uses matrix factorization. In its basic form, matrix factorization characterizes both items and users by vectors of factors inferred from item rating patterns.",
    "Description Reference": "https://doi.org/10.1109/MC.2009.263",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 93,
    "Family Name": "Feature Detection",
    "Variation": "Corner Detection",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Conventionally, a corner is defined as the intersection point or the junction point between two or more straight line edges (i.e. edges which have discontinuities along a straight line). Corner detection is the problem of detecting such corners in a given image.",
    "Description Reference": "https://doi.org/10.1016/0031-3203(90)90118-5",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 94,
    "Family Name": "Feature Detection",
    "Variation": "Blob Detection",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The regions or points which have noticeable difference with their surroundings is called blob. Blob detection is the problem of detecting such blobs in a given image.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7467122",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 95,
    "Family Name": "Culling",
    "Variation": "Culling",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Culling is the process of rejecting primitives or objects in their entireity before rendering in the case that they would not be shown in the view, reducing unnecessary computations.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/253284.253312",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 96,
    "Family Name": "Filtering Problem (Stochastic Processes)",
    "Variation": "Filtering Problem (Stochastic Processes)",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The filtering problem is to obtain the best linear estimate $\\hat{z}_t$ of $z_t$ based on the past observations ($y_s | s\\leq t)$. Abstractly, the solution to the problem of filtering corresponds to explicitly computing\n\n$\\hat{z}_t = P_t^y(z_t)$\n\nwhere $P_t^y$ is the projection operator onto the Hilbert space $H_t^y$.",
    "Description Reference": "https://ieeexplore.ieee.org/abstract/document/506400",
    "Parameters": "$n$: number of dimensions in state space",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Statistics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 97,
    "Family Name": "Optimal Policies for MDPs",
    "Variation": "Optimal Policies for MDPs",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In an MDP, a policy is a choice of what action to choose at each state An Optimal Policy is a policy where you are always choosing the action that maximizes the “return”/”utility” of the current state. The problem here is to find such an optimal policy from a given MDP.",
    "Description Reference": "https://mas.cs.umass.edu/classes/cs683/lectures-2010/Lec13_MDP2-F2010-4up.pdf",
    "Parameters": "$n$: number of states",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 98,
    "Family Name": "The Set-Covering Problem",
    "Variation": "Unweighted Set-Covering",
    "Alias": "",
    "Parents": "Weighted Set-Covering",
    "Children": "",
    "Problem Description": "Given a universe $U$, i.e. a set of elements $\\{1, 2, \\ldots, n\\}$, and a collection $S$ of $m$ sets whose union is the universe, identify the smallest sub-collection of $S$ whose union is the universe.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/237814.237991",
    "Parameters": "$U$: the universe of elements to be covered\n$S$: the collection of sets\n$n$: number of elements in the universe\n$m$: number of sets in the collection\n$H(x)$: the $x^{th}$ Harmonic number",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "$\\Omega(n^{2-\\epsilon}\\poly(d))$",
    "Lower Bound Reference": "Hypothesis #9 (#5 in the linked paper)",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 98,
    "Family Name": "The Set-Covering Problem",
    "Variation": "Weighted Set-Covering",
    "Alias": "",
    "Parents": "",
    "Children": "Unweighted Set-Covering;",
    "Problem Description": "The set-covering problem where each set $s\\in S$ is assigned a weight and the goal is to find the minimum weight sub-collection of $S$ that covers the universe.",
    "Description Reference": "https://www.jstor.org/stable/pdf/3689577.pdf",
    "Parameters": "$U$: the universe of elements to be covered\n$S$: the collection of sets\n$n$: number of elements in the universe\n$m$: number of sets in the collection\n$H(x)$: the $x^{th}$ Harmonic number",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "$\\Omega(n^{2-\\epsilon}\\poly(d))$",
    "Lower Bound Reference": "Hypothesis #9 (#5 in the linked paper)",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 99,
    "Family Name": "Motif Search",
    "Variation": "Motif Search",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Motif search is the problem of identifying motifs, recurring or conserved patterns, in the strings (typically biological sequence data sets).",
    "Description Reference": "https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-8-S7-S21#MOESM6",
    "Parameters": "$n$: size of set of input strings\n$m$: size of input strings\n$k$: length of substrings\n$\\sigma$: function $V(k, m)$ defined as the number of $k$-mers that are at most $m$ Hamming distance from the motif space",
    "Parameter for graphs": "mn",
    "Input Size": "O(mn)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "$\\Omega(n)$",
    "Lower Bound Reference": "Trivial",
    "Domain": "Bioinformatics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 99,
    "Family Name": "Motif Search",
    "Variation": "Edit-distance-based Motif Search",
    "Alias": "EMS",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 100,
    "Family Name": "All Maximal Non-Branching Paths in a Graph",
    "Variation": "All Maximal Non-Branching Paths in a Graph",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "A node $v$ in a directed graph $G$ is called a 1-in-1-out node if its indegree and outdegree are both equal to 1, i.e., $in(v) = out(v) = 1$.  We can rephrase the definition of a \"maximal non-branching path\" from the main text as a path whose internal nodes are 1-in-1-out nodes and whose initial and final nodes are not 1-in-1-out nodes.\n\nThe problem is to find all maximal non-branching paths in a given graph.",
    "Description Reference": "https://rosalind.info/problems/ba3m/",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "O(m + n)",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Bioinformatics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 101,
    "Family Name": "Link Analysis",
    "Variation": "InDegree Analysis",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "A simple heuristic that can be viewed as the predecessor of all Link Analysis Ranking algorithms is to rank the pages according to their popularity (also referred to as visibility [Marchiori 1997]). The popularity of a page is measured by the number of pages that link to this page. We refer to this algorithm as the InDegree algorithm, since it ranks pages according to their in-degree in the graph $G$. That is, for every node $i$, $a_i = |B(i)|$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/1052934.1052942",
    "Parameters": "$n$: number of pages\n$m$: number of hyperlinks\n$z$: # of topics/categories",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "http://snap.stanford.edu/class/cs224w-readings/borodin05pagerank.pdf",
    "__1": "https://ipsen.math.ncsu.edu/ps/simax43980.pdf",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 101,
    "Family Name": "Link Analysis",
    "Variation": "Personalized PageRank",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 101,
    "Family Name": "Link Analysis",
    "Variation": "Dynamic Personalized PageRank",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 101,
    "Family Name": "Link Analysis",
    "Variation": "Single-Sourced Personalized PageRank",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 101,
    "Family Name": "Link Analysis",
    "Variation": "Link Analysis/PageRank",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 102,
    "Family Name": "Image Compositing",
    "Variation": "Image Compositing",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Image compositing is the act of creating a single image from multiple images.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/800031.808606",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 103.1,
    "Family Name": "Texture Synthesis",
    "Variation": "Texture Synthesis",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a texture sample, synthesize a new texture that, when perceived by a human observer, appears to be generated by the same underlying stochastic process.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/344779.345009",
    "Parameters": "$n$: number of pixels",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 103.2,
    "Family Name": "Distributed Locking Algorithms",
    "Variation": "Distributed Locking Algorithms",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The purpose of a lock is to ensure that among several nodes that might try to do the same piece of work, only one actually does it (at least only one at a time). That work might be to write some data to a shared storage system, to perform some computation, to call some external API, or suchlike. At a high level, there are two reasons why you might want a lock in a distributed application: for efficiency or for correctness.",
    "Description Reference": "https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html",
    "Parameters": "$n$: number of clients\n$f$: number of files",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 104,
    "Family Name": "Cyclic Peptide Sequencing Problem",
    "Variation": "Cyclic Peptide Sequencing Problem",
    "Alias": "CPSP",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an experimental $MS^3$ spectrum $S$, find a cyclic peptide $P$ maximizing the number of shared masses between $S$ and the theoretical spectrum of $P$.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/978-3-540-78839-3_16.pdf",
    "Parameters": "$n$: size of peptide, in daltons\n$m$: number of elements in experimental spectrum",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Bioinformatics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 105,
    "Family Name": "Texture Mapping",
    "Variation": "Diffuse Reflection",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Texture mapping means the mapping of a function onto a surface in 3D. The domain of the function can be one, two, or three dimensional, and it can be represented by either an array or a mathematical function.\n\nThe source image (texture) is mapped onto a surface in 3D object space, which is then mapped to the destination image (screen) by the viewing projection. Texture space is labeled $(u, v)$, object space is labeled $(x_0, y_0, z_0)$, and screen space is labeled $(x, y)$.\n\nDiffuse reflection is the light that is scattered off of the incident surface.",
    "Description Reference": "https://web.archive.org/web/20100727005751/http://www.cs.berkeley.edu/~ravir/6998/papers/p165-hanrahan.pdf",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 106,
    "Family Name": "Texture Mapping",
    "Variation": "Specular Reflection",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Texture mapping means the mapping of a function onto a surface in 3D. The domain of the function can be one, two, or three dimensional, and it can be represented by either an array or a mathematical function.\n\nThe source image (texture) is mapped onto a surface in 3D object space, which is then mapped to the destination image (screen) by the viewing projection. Texture space is labeled $(u, v)$, object space is labeled $(x_0, y_0, z_0)$, and screen space is labeled $(x, y)$.\n\nSpecular reflection is the light that is perfectly reflected off of the incident surface.",
    "Description Reference": "https://web.archive.org/web/20100727005751/http://www.cs.berkeley.edu/~ravir/6998/papers/p165-hanrahan.pdf",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 107,
    "Family Name": "Point-in-Polygon",
    "Variation": "Point-in-Polygon",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "With a given polygon $P$ and an arbitrary point $q$, determine whether point $q$ is enclosed by the edges of the polygon.",
    "Description Reference": "https://ir.nctu.edu.tw/bitstream/11536/749/1/A1997WM15100010.pdf",
    "Parameters": "$n$: number of edges of polygon",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 108,
    "Family Name": "Image Segmentation",
    "Variation": "Image Segmentation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Image segmentation is the division of an image into different regions, each having certain properties. It is the first step of image analysis which aims at either a description of an image or a classification of the image if a class label is meaningful. An example of the former is the description of an office\nscene. An example of the latter is the classification of the image of a cancerous cell. Image segmentation is a critical component of an image recognition system because errors in segmentation might propagate to feature extraction and classification.",
    "Description Reference": "http://www.ttcenter.ir/ArticleFiles/ENARTICLE/3405.pdf",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 109,
    "Family Name": "Mesh Simplification",
    "Variation": "Mesh Simplification",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a surface mesh, accurately simplify it so that you may render the mesh accurately with less computing power.",
    "Description Reference": "http://webdocs.cs.ualberta.ca/~anup/Courses/604_3DTV/Presentation_files/Polygon_Simplification/7.pdf",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 110,
    "Family Name": "Clock Synchronization in Distributed Systems",
    "Variation": "Clock Synchronization in Distributed Systems",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The difference between the largest and the smallest clock values among all stations in a Mobile Ad Hoc Network (MANET) is called the maximum clock offset. The goal is to minimize the maximum clock offset.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4359404",
    "Parameters": "$n$: number of nodes in network",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 111,
    "Family Name": "POMDPs",
    "Variation": "POMDPs",
    "Alias": "Partially Observable Markov Decision Process",
    "Parents": "",
    "Children": "",
    "Problem Description": "At (discrete) time step $t$, the environment is assumed to be in some state $X_t$. The agent then performs an action (control) $A_t$, whereupon the environment (stochastically) changes to a new state $X_{t+1}$. The agent doesn’t see the environment state, but instead receives an observation $Y_t$, which is some (stochastic) function of $X_t$. (If $Y_t = X_t$, the POMDP reduces to a fully observed MDP.) In addition, the agent receives a special observation signal called the reward, $R_t$. The POMDP is characterized by the state transition function $P(X_{t+1}|X_t, A_t)$, the observation function $P(Y_t|X_t, A_{t−1})$, and the reward function $E(R_t|X_t, A_{t−1})$. The goal of the agent is to learn a policy $\\pi$ which maps the observation history (trajectory) into an action $A_t$ to maximize $\\pi$’s quality or value.",
    "Description Reference": "https://www.techfak.uni-bielefeld.de/~skopp/Lehre/STdKI_SS10/POMDP_survey.pdf",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 112,
    "Family Name": "Rasterization",
    "Variation": "Rasterization",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Raster-scan displays are most commonly driven by a frame buffer, a memory that stores the color value for every picture element on the screen and refreshes the display continuously. The process of generating these picture clement values from a geometric description of the image is known as rasterization.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/74333.74370",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Image Processing",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 113,
    "Family Name": "Texture Mapping",
    "Variation": "Environment Mapping",
    "Alias": "Reflection Mapping; Illumination Mapping;",
    "Parents": "",
    "Children": "",
    "Problem Description": "Texture mapping means the mapping of a function onto a surface in 3D. The domain of the function can be one, two, or three dimensional, and it can be represented by either an array or a mathematical function.\n\nThe source image (texture) is mapped onto a surface in 3D object space, which is then mapped to the destination image (screen) by the viewing projection. Texture space is labeled $(u, v)$, object space is labeled $(x_0, y_0, z_0)$, and screen space is labeled $(x, y)$.\n\nIllumination mapping is the mapping of specular or diffuse reflection. It is also known as reflection mapping or environment mapping.",
    "Description Reference": "https://doi.org/10.1109/MCG.1986.276672",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 114,
    "Family Name": "Occupancy Grid Mapping",
    "Variation": "Occupancy Grid Mapping",
    "Alias": "OGM",
    "Parents": "",
    "Children": "",
    "Problem Description": "Assuming a robot's pose is known, generate a occupancy grid mapping of the area. The occupancy grid is a multidimensional random field that maintains stochastic estimates of the occupancy state of the cells in a spatial lattice. To construct a sensor-derived map of the robot’s world, the cell state estimates are obtained by interpreting the incoming range readings using probabilistic sensor models. Bayesian estimation procedures allow the incremental updating of the occupancy grid using readings taken from several sensors over multiple points of view.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=30720",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 115,
    "Family Name": "SLAM Algorithms",
    "Variation": "SLAM Algorithms",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Simultaneous localization and mapping (SLAM) is the computational problem of constructing or updating a map of an unknown environment while simultaneously keeping track of an agent's location within it.",
    "Description Reference": "http://ais.informatik.uni-freiburg.de/teaching/ss12/robotics/slides/12-slam.pdf",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 116,
    "Family Name": "d-Neighborhood of a String",
    "Variation": "d-Neighborhood of a String",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a DNA string pattern and an integer $d$, find the collection of strings that are within a $d$-neighborhood of the given pattern. A $d$-neighborhood is the set of all $k$-mers whose Hamming distance from the pattern is at most $d$.",
    "Description Reference": "https://rosalind.info/problems/ba1n/",
    "Parameters": "$n$: length of string\n$d$: neighborhood distance threshold\n$\\sigma$: size of alphabet",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Bioinformatics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 117,
    "Family Name": "Maximum Cut",
    "Variation": "Maximum Cut",
    "Alias": "Max Cut",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a graph $G=(V, E)$ with edge weights $c_e > 0$ for all $e\\in E$, find a cut $\\delta(W)$ such that $c(\\delta(W)):=\\Sigma_{e\\in \\dela(W)} c_e$ is as large as possible.",
    "Description Reference": "https://doi.org/10.1016/0167-6377(81)90020-1",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 118,
    "Family Name": "Wiener Index",
    "Variation": "Minimum Wiener Connector Problem",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a connected graph $G = (V, E)$ and a set $Q \\subseteq V$ of query vertices, find a subgraph of $G$ that connects all query vertices and has minimum Wiener index.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/2723372.2749449",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$q$: number of query vertices",
    "Parameter for graphs": "n",
    "Input Size": "O(n+m)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "$\\tilde{O}(qm) for an O(1)-approximation",
    "Upper Bound Reference": "https://dl.acm.org/doi/10.1145/2723372.2749449",
    "Best Known Lower Bound": "NP-Hard",
    "Lower Bound Reference": "https://dl.acm.org/doi/10.1145/2723372.2749449",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 118,
    "Family Name": "Wiener Index",
    "Variation": "Undirected Wiener Index",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Calculate the sum of the lengths of the shortest paths between all pairs of vertices in an undirected graph (typically in the chemical graph representing the non-hydrogen atoms in the molecule).",
    "Description Reference": "https://arxiv.org/pdf/1712.08147v2.pdf",
    "Parameters": "$n$: number of vertices (number of non-hydrogen atoms in the molecule)",
    "Parameter for graphs": "n",
    "Input Size": "O(n+m)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 119,
    "Family Name": "Determinant of Matrices with Integer Entries",
    "Variation": "Determinant of Matrices with Integer Entries",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Calculate the determinant of a given matrix with integer matrices. For such matrices, the determinant is also an integer.",
    "Description Reference": "https://www.ams.org/journals/mcom/1968-22-103/S0025-5718-1968-0226829-0/S0025-5718-1968-0226829-0.pdf",
    "Parameters": "$n$: dimension of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "O(n^2)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 120,
    "Family Name": "Integer Relation",
    "Variation": "Integer Relation Among Reals",
    "Alias": "",
    "Parents": "",
    "Children": "Integer Relation Among Integers;",
    "Problem Description": "Given a vector $x \\in \\mathbb{R}^n$, find an integer relation, i.e. a non-zero vector $m \\in \\mathbb{Z}^n$ such that $<x, m> = 0$",
    "Description Reference": "https://epubs.siam.org/doi/pdf/10.1137/0218059",
    "Parameters": "$n$: dimensionality of vectors",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "O(n^3)",
    "Upper Bound Reference": "Algo #925",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 120,
    "Family Name": "Integer Relation",
    "Variation": "Integer Relation Among Integers",
    "Alias": "",
    "Parents": "Integer Relation Among Reals",
    "Children": "",
    "Problem Description": "Given a vector $x \\in \\mathbb{Z}^n$, find an integer relation, i.e. a non-zero vector $m \\in \\mathbb{Z}^n$ such that $<x, m> = 0$",
    "Description Reference": "https://epubs.siam.org/doi/pdf/10.1137/0218059",
    "Parameters": "$n$: dimensionality of vectors",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 122,
    "Family Name": "Sequence-to-Graph Alignment",
    "Variation": "Sequence-To-Graph Alignment",
    "Alias": "Pattern Matching on Hypertext",
    "Parents": "",
    "Children": "",
    "Problem Description": "This is pattern matching where you are given a pattern and a hypertext graph. The hypertext model is that the text forms a graph of $N$ nodes and $E$ edges, where a string is stored inside each node, and the edges indicate alternative texts that may follow the current node. The pattern is still a simple string of length $m$. It is also customary to transform this graph into a one-character hypertext, i.e. one where there is exactly one character per node (by converting each node containing a text of length $l$ into a chain of $l$ nodes). This graph has $n$ nodes and $e$ edges (note that $n$ is the text size and $e = n − N + E$).\n\nAdditonal notes: (changes are allowed in the query sequence alone) Linear gap penalty?",
    "Description Reference": "https://doi.org/10.1016/S0304-3975(99)00333-3",
    "Parameters": "$N$: number of vertices in original hypertext graph\n$E$: number of edges in original hypertext graph\n$m$: length of pattern\n$n$: number of vertices in converted graph (total text size)\n$e$: number of edges in converted graph",
    "Parameter for graphs": "N",
    "Input Size": "O(N + E + m)",
    "Output Size": "O(n + e)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 122,
    "Family Name": "Sequence-to-Graph Alignment",
    "Variation": "Sequence-to-Graph Alignment with DAGs",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 123,
    "Family Name": "Logarithm Calculations",
    "Variation": "Discrete Logarithm Over Finite Fields",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Let $F_{p^n}$ denote the finite field of $p^n$ elements, where $p$ is a prime. Let $x$ be a generator for the multiplicative group of $F_{p^n}$. The discrete logarithm problem over $F_{p^n}$ is to compute, for any given nonzero $h \\in F_{p^n}$, the least nonnegative integer $e$ such that $x^e=h$. In this context we shall write $e=\\log_x h$.",
    "Description Reference": "https://doi.org/10.1006/inco.1998.2761",
    "Parameters": "$n$: number of digits/bits in the order of the finite group",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Statistics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 124,
    "Family Name": "Rod-Cutting Problem",
    "Variation": "Rod-Cutting Problem",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a rod of length $n$, and prices $p_i$ for which one can sell a segment of the rod of length $i$ ($1 \\leq i \\leq n$), find the splitting of the rod for which one can earn the most money once they sell the rod segments produced.",
    "Description Reference": "https://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture12.pdf",
    "Parameters": "$n$: length of rod",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^2)",
    "Upper Bound Reference": "dynamic programming",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 125,
    "Family Name": "Self-Balancing Trees Creation",
    "Variation": "Self-Balancing Trees Creation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Create a self-balancing tree given a list of elements.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4567957",
    "Parameters": "$n$: size of tree",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 126,
    "Family Name": "Self-Balancing Trees Insertion",
    "Variation": "Self-Balancing Trees Insertion",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Insert a given element into a self-balancing tree.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4567957",
    "Parameters": "$n$: size of tree",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 127,
    "Family Name": "Self-Balancing Trees Deletion",
    "Variation": "Self-Balancing Trees Deletion",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Delete a given element from a self-balancing tree.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4567957",
    "Parameters": "$n$: size of tree",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(n)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 128,
    "Family Name": "Self-Balancing Trees Search",
    "Variation": "Self-Balancing Trees Search",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Search for a given element within a self-balancing tree.",
    "Description Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4567957",
    "Parameters": "$n$: size of tree",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "O(1)",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 129,
    "Family Name": "Transitive Reduction Problem",
    "Variation": "Transitive Reduction Problem of Directed Graphs",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "A directed graph $G^t$ is said to be a transitive reduction of the directed graph $G$ provided that (i) $G$ has a directed path from vertex $u$ to vertex $v$ if and only if $G$ has a directed path from vertex $u$ to vertex $v$, and (ii) there is no graph with fewer arcs than $G^t$ satisfying condition (i). The problem asks to find such a graph $G^t$ for a given digraph $G$.",
    "Description Reference": "https://epubs.siam.org/doi/pdf/10.1137/0201008",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "O(n+m)",
    "Output Size": "O(n^2)",
    "Best Known Upper Bound": "O(n^omega) where omega is the exponent on boolean matrix multiplication",
    "Upper Bound Reference": "https://epubs.siam.org/doi/pdf/10.1137/0201008",
    "Best Known Lower Bound": "Omega(n^2)",
    "Lower Bound Reference": "Easily derived (equal to output size)",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 130,
    "Family Name": "Change-Making Problem",
    "Variation": "Change-Making Problem",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an unlimited amount of coins of denominations $c_1, \\ldots, c_n$, and a desired sum $S$, find the minimum number of coins necessary to make $S$.",
    "Description Reference": "https://dl.acm.org/doi/10.1145/321864.321874",
    "Parameters": "$n$: number of coin denominations\n$S$: sum to be made",
    "Parameter for graphs": "n",
    "Input Size": "O(n)",
    "Output Size": "",
    "Best Known Upper Bound": "O(nS)",
    "Upper Bound Reference": "dynamic programming",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 131,
    "Family Name": "Turnpike Problem",
    "Variation": "Turnpike Problem",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given $n$ points and $\\binom{n}{2}$ distances, find each distance's corresponding pair of points.",
    "Description Reference": "http://hariharan-ramesh.com/ppts/turnpike.pdf",
    "Parameters": "$n$: number of points",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n n \\log n)",
    "Upper Bound Reference": "http://hariharan-ramesh.com/ppts/turnpike.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "https://sandbox.dodona.be/en/activities/1441444585/description/sKfgfbq-Wnx-ufBY/media/Dakic2000.pdf",
    "__1": "<= see this reference as well",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 132,
    "Family Name": "n-Queens Problem",
    "Variation": "Counting Solutions",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "How many ways can one put $n$ queens on an $n \\times n$ chessboard so that no two queens attack each other? In other words, how many points can be placed on an $n \\times n$ grid so that no two are on the same row, column, or diagonal?",
    "Description Reference": "https://doi.org/10.1080/00029890.1994.11997004",
    "Parameters": "$n$: number of queens, size of chessboard",
    "Parameter for graphs": "n^2",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n)",
    "Upper Bound Reference": "https://dl.acm.org/citation.cfm?id=1243380",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 132,
    "Family Name": "n-Queens Problem",
    "Variation": "Constructing Solutions",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "What are all of the ways can one put $n$ queens on an $n \\times n$ chessboard so that no two queens attack each other?",
    "Description Reference": "https://doi.org/10.1080/00029890.1994.11997004",
    "Parameters": "$n$: number of queens, size of chessboard",
    "Parameter for graphs": "n^2",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n)",
    "Upper Bound Reference": "https://dl.acm.org/citation.cfm?id=1243380",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 132,
    "Family Name": "n-Queens Problem",
    "Variation": "n-Queens Completion",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an $n \\times n$ chessboard that already has $k$ queens on it, complete the board such that there are $n$ queens, all of which cannot attack each other.",
    "Description Reference": "https://doi.org/10.1080/00029890.1994.11997004",
    "Parameters": "$n$: size of chessboard\n$k$: number of queens given",
    "Parameter for graphs": "n^2",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 133,
    "Family Name": "Median String Problem",
    "Variation": "Median String Problem with Unbounded Alphabets",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an unbounded alphabet $\\Sigma$, a set $W$ of strings over $\\Sigma$, and the Levenshtein distance between strings, find a string over $\\Sigma$ that minimizes the sum of distances to the strings of $W$.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/3-540-44888-8_23.pdf",
    "Parameters": "$n$: number of strings",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "2^O(n)",
    "Upper Bound Reference": "https://link.springer.com/content/pdf/10.1007/3-540-44888-8_23.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 133,
    "Family Name": "Median String Problem",
    "Variation": "Median String Problem with Bounded Alphabets",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a bounded alphabet $\\Sigma$, a set $W$ of strings over $\\Sigma$, and the Levenshtein distance between strings, find a string over $\\Sigma$ that minimizes the sum of distances to the strings of $W$.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/3-540-44888-8_23.pdf",
    "Parameters": "$n$: number of strings",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "2^O(n)",
    "Upper Bound Reference": "https://link.springer.com/content/pdf/10.1007/3-540-44888-8_23.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 133,
    "Family Name": "Median String Problem",
    "Variation": "Median String Problem with Binary Alphabets",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a binary alphabet $\\Sigma$, a set $W$ of strings over $\\Sigma$, and the Levenshtein distance between strings, find a string over $\\Sigma$ that minimizes the sum of distances to the strings of $W$.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/3-540-44888-8_23.pdf",
    "Parameters": "$n$: number of strings",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n)",
    "Upper Bound Reference": "https://link.springer.com/content/pdf/10.1007/3-540-44888-8_23.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 134,
    "Family Name": "Frequent Words with Mismatches Problem",
    "Variation": "Frequent Words with Mismatches Problem",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given two strings, determine the most frequent substring with at most $k$ mismatches, where mismatches are not counted towards the length of the substring.",
    "Description Reference": "https://academic.oup.com/bioinformatics/article/30/14/2000/2391348",
    "Parameters": "$n$: length of string\n$k$: length of words\n$d$: number of allowed mismatches\n$\\sigma$: size of alphabet",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^2)",
    "Upper Bound Reference": "?",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 135,
    "Family Name": "Tower of Hanoi",
    "Variation": "Tower of Hanoi",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "The Tower of Hanoi puzzle consists of $n$ discs, no two of the same size, stacked on $p \\geq 3$ vertical pegs, in such a way that no disc lies on top of a smaller disc. A permissible $move$ is to take the top disc from one of the pegs and move it to one of the other pegs, as long as it is not placed on top of a smaller disc. Initially, they are all stacked on the first peg. The goal is to end up with them all stacked on the last peg.",
    "Description Reference": "https://www.fmf.uni-lj.si/~klavzar/preprints/topdiscs-scan.pdf",
    "Parameters": "$n$: number of discs\n$p$: number of pegs",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 136,
    "Family Name": "The Frequent Words Problem",
    "Variation": "The Frequent Words Problem",
    "Alias": "The Frequent $k$-mers Problem",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a string of length $n$ and in input integer $k$, determine the most frequent $k$-mers in the string, i.e. the most frequent words of length $k$.",
    "Description Reference": "https://bioinformaticsalgorithms.com/data/debugdatasets/replication/FrequentWordsProblem.pdf",
    "Parameters": "$n$: length of string\n$k$: length of words\n$\\sigma$: size of alphabet",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "http://bioinformaticsalgorithms.com/data/debugdatasets/replication/FrequentWordsProblem.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Statistics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 137,
    "Family Name": "Integral Equations",
    "Variation": "Fredholm Equations",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Integral equations are equations where an unknown function appears under an integral sign.\n\nFredholm equations have both limits of integration fixed, and there are three types of Fredholm equations.",
    "Description Reference": "https://books.google.com/books?hl=en&lr=&id=JFU0ltx0E68C&oi=fnd&pg=PR3&dq=integral+equations&ots=Kp98jJWIJT&sig=CXobYQkw_g35JhZ6qKjdy7P1idw#v=onepage&q=integral%20equations&f=false",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 137,
    "Family Name": "Integral Equations",
    "Variation": "Volterra Equations",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Integral equations are equations where an unknown function appears under an integral sign.\n\nVolterra equations have one limit of integration fixed while the other is a variable.",
    "Description Reference": "https://books.google.com/books?hl=en&lr=&id=JFU0ltx0E68C&oi=fnd&pg=PR3&dq=integral+equations&ots=Kp98jJWIJT&sig=CXobYQkw_g35JhZ6qKjdy7P1idw#v=onepage&q=integral%20equations&f=false",
    "Parameters": "",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 138,
    "Family Name": "One-Way Hash Functions",
    "Variation": "Keyed Hash Functions",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "A hash function, otherwise known as a one-way hash function, takes an arbitrary message of arbitrary length and creates an output (a hash) of a fixed length. The main characteristics of a cryptographic hash function are that given a message, it is easy to compute the hash; given the hash, it is difficult to compute the message; and that given a message, it is difficult to find a different message that would produce the same hash (this is known as a collision).\n\nA keyed hash function takes a message and a secret key as input and outputs a fixed-length hash.",
    "Description Reference": "https://doi.org/10.1016/B0-12-227240-4/00054-X",
    "Parameters": "n: length of message",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Cryptography",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 138,
    "Family Name": "One-Way Hash Functions",
    "Variation": "Unkeyed Hash Functions",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "A hash function, otherwise known as a one-way hash function, takes an arbitrary message of arbitrary length and creates an output (a hash) of a fixed length. The main characteristics of a cryptographic hash function are that given a message, it is easy to compute the hash; given the hash, it is difficult to compute the message; and that given a message, it is difficult to find a different message that would produce the same hash (this is known as a collision).\n\nAn unkeyed hash function takes just a message as input and outputs a fixed-length hash.",
    "Description Reference": "https://doi.org/10.1016/B0-12-227240-4/00054-X",
    "Parameters": "n: length of message",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Cryptography",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 139,
    "Family Name": "Secret Sharing",
    "Variation": "Secret Sharing",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Secret Sharing is the splitting up of a secret amongst a group such that no individual can learn the entire secret alone, but when a sufficient amount of the group comes together with their parts of the secret, they can reconstruct the secret.",
    "Description Reference": "https://doi.org/10.1145%2F359168.359176",
    "Parameters": "$n$: size of the group the secret is being shared with\n$t$: threshold number of players",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Cryptography",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 140,
    "Family Name": "Solutions to Nonlinear Equations",
    "Variation": "Solutions to Nonlinear Equations",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Compute the solutions to a given nonlinear equation of the form $f(x) = 0$.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/s11075-006-9015-9.pdf",
    "Parameters": "$\\epsilon$: (additive) tolerance error\n$a, b$: endpoint values, with $b>a$\n$n_{max}$: maximum number of iterations$",
    "Parameter for graphs": "n_max",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 141,
    "Family Name": "Block Ciphers",
    "Variation": "Block Ciphers",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "A block cipher is a pair of functions $E: \\{0, 1\\}^k \\times \\{0, 1\\}^n \\rightarrow \\{0, 1\\}^n$ and $D: \\{0, 1\\}^k \\times \\{0, 1\\}^n \\rightarrow \\{0, 1\\}^n$ that encode and decode a length $n$ string with a length $k$ key.",
    "Description Reference": "https://www.cs.ucdavis.edu/~rogaway/classes/227/spring05/book/main.pdf",
    "Parameters": "$n$: text length (block size)\n$k$: key length",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Cryptography",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 142,
    "Family Name": "Polynomial Interpolation",
    "Variation": "Polynomial Interpolation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a finite number of points $x_1, \\ldots , x_n$, some real constants $y_1, \\ldots , y_n$ and a subspace $V$ of $\\Pi^d$, find a polynomial $p \\in V$, such that\n\n$p(x_j) = y_j$, $j = 1, ... , n$",
    "Description Reference": "https://link.springer.com/content/pdf/10.1023/A:1018981505752.pdf",
    "Parameters": "$n$: number of points\n$d$: dimension of space",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Numerical Analysis",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 142,
    "Family Name": "Polynomial Interpolation",
    "Variation": "2-D Polynomial Interpolation",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 143,
    "Family Name": "Greatest Common Divisor",
    "Variation": "Greatest Common Divisor",
    "Alias": "GCD",
    "Parents": "",
    "Children": "",
    "Problem Description": "Let $a_1, \\ldots, a_m$ be given nonzero integers. Then $g$ is called the greatest common divisor (GCD) of $a_1, \\ldots, a_m$ if and only if it is the largest integer that divides all $a_1, \\ldots, a_m$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/321662.321664",
    "Parameters": "$n$: sum of number of bits among the integers",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Statistics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 145,
    "Family Name": "Interval Scheduling",
    "Variation": "Unweighted Interval Scheduling",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given are $n$ intervals of the form $[s_j , f_j)$ with $s_j < f_j$, for $j = 1, \\ldots , n$. These intervals are the jobs that require uninterrupted processing during that interval. We will assume (without loss of generality) that the $s_j$’s and the $f_j$’s are nonnegative integers. We say that two intervals (or jobs) overlap if their intersection is nonempty, otherwise they are called disjoint. Further, there are machines. In the basic interval scheduling problem each machine can process at most one job at a time and is always available, i.e. each machine is continuously available in $[0,\\infty)$. We assume that, when processed, each job is assigned to a single machine, thus, we do not allow interrupting a job and resuming it on another machine, unless explicitly stated otherwise. The basic interval scheduling problem is now to process all jobs using a minimum number of machines. In other words, find an assignment of jobs to machines such that no two jobs assigned to the same machine overlap while using a minimum number of machines. We call an assignment of (a subset of) the jobs to the machines a schedule.",
    "Description Reference": "https://onlinelibrary.wiley.com/doi/pdf/10.1002/nav.20231",
    "Parameters": "$n$: number of tasks (intervals)\n$k$: number of machines (resources)",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 145,
    "Family Name": "Interval Scheduling",
    "Variation": "Unweighted Interval Scheduling, Online",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given are $n$ intervals of the form $[s_j , f_j)$ with $s_j < f_j$, for $j = 1, \\ldots , n$. These intervals are the jobs that require uninterrupted processing during that interval. We will assume (without loss of generality) that the $s_j$’s and the $f_j$’s are nonnegative integers. We say that two intervals (or jobs) overlap if their intersection is nonempty, otherwise they are called disjoint. Further, there are machines. In the basic interval scheduling problem each machine can process at most one job at a time and is always available, i.e. each machine is continuously available in $[0,\\infty)$. We assume that, when processed, each job is assigned to a single machine, thus, we do not allow interrupting a job and resuming it on another machine, unless explicitly stated otherwise. The basic interval scheduling problem is now to process all jobs using a minimum number of machines. In other words, find an assignment of jobs to machines such that no two jobs assigned to the same machine overlap while using a minimum number of machines. We call an assignment of (a subset of) the jobs to the machines a schedule.\n\nThis is the online version of the problem.",
    "Description Reference": "https://onlinelibrary.wiley.com/doi/pdf/10.1002/nav.20231",
    "Parameters": "$n$: number of tasks (intervals)\n$k$: number of machines (resources)",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 145,
    "Family Name": "Interval Scheduling",
    "Variation": "Weighted Interval Schedule Maximization Problem (ISMP)",
    "Alias": "Weighted Activity Selection Problem",
    "Parents": "",
    "Children": "",
    "Problem Description": "In Weighted Interval Scheduling, each interval has an associated weight. The goal is to maximize the weights of the accepted (and not interrupted) intervals.",
    "Description Reference": "https://onlinelibrary.wiley.com/doi/pdf/10.1002/nav.20231",
    "Parameters": "$n$: number of tasks (intervals)\n$k$: number of machines (resources)",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 145,
    "Family Name": "Interval Scheduling",
    "Variation": "Preemptive Scheduling on Many Machines, Minimize Lateness",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 147,
    "Family Name": "Deadlock Avoidance",
    "Variation": "Deadlock Avoidance",
    "Alias": "",
    "Parents": "",
    "Children": "Dining Philosophers Problem;",
    "Problem Description": "A deadlock means that the processing of some parts, once started, cannot finish because each of these parts requests for its advancement some resource(s) currently held by some other part(s) in this set.\n\nIn a deadlock avoidance approach, the controller must ensure that the granting of resources to any process will lead to a resulting state which is “safe,” i.e., a state from which all the parts being processed can terminate.",
    "Description Reference": "https://doi.org/10.1109/TRA.2002.801048",
    "Parameters": "$n$: number of processes\n$m$: number of resource types",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 146,
    "Family Name": "Deadlock Avoidance",
    "Variation": "Dining Philosophers Problem",
    "Alias": "",
    "Parents": "Deadlock Avoidance",
    "Children": "",
    "Problem Description": "There are $n$ philosophers numbered 0 through $n-1$, seated around a circle table. Their only problem--besides philosophy--is that the dish served is a very difficult kind of spaghetti, that has to be eaten with two forks. There are two forks next to each plate, so that presents no difficulty: as a consequence, however, no two neighbors may be eating simultaneously. The philosophers' lives consist of an alternation between eating and thinking. The goal is to devise a strategy such that no philosopher is stuck thinking forever and each philosopher may eat at reasonable intervals.",
    "Description Reference": "https://www.cs.utexas.edu/~EWD/ewd03xx/EWD310.PDF",
    "Parameters": "$n$: number of philosophers",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 148,
    "Family Name": "Page Replacements",
    "Variation": "Offline",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "When page fault occurs during the program execution, operating systems use page replacement algorithms to select a victim page from primary memory and makes room for the required page.",
    "Description Reference": "https://www.researchgate.net/profile/Gyanendra-Kumar-3/publication/319467661_A_Novel_Longest_Distance_First_Page_Replacement_Algorithm/links/59b209f1aca2728472d14684/A-Novel-Longest-Distance-First-Page-Replacement-Algorithm.pdf",
    "Parameters": "$n$: number of page requests\n$k$: number of pages able to fit in cache",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 148,
    "Family Name": "Page Replacements",
    "Variation": "Online",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "When page fault occurs during the program execution, operating systems use page replacement algorithms to select a victim page from primary memory and makes room for the required page.",
    "Description Reference": "https://www.researchgate.net/profile/Gyanendra-Kumar-3/publication/319467661_A_Novel_Longest_Distance_First_Page_Replacement_Algorithm/links/59b209f1aca2728472d14684/A-Novel-Longest-Distance-First-Page-Replacement-Algorithm.pdf",
    "Parameters": "$n$: number of page requests\n$k$: number of pages able to fit in cache",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 149,
    "Family Name": "Recovery",
    "Variation": "Steal, No-Force",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Recovery is the process of reverting back to a safe state prior to a system failure.\n\nWith a Steal/No-Force policy, the recovery algorithm will write possibly uncommited data to memory, while not forcing all commits to memory.",
    "Description Reference": "https://dsf.berkeley.edu/jmh/cs186/f02/lecs/lec25_6up.pdf",
    "Parameters": "$n$: number of transactions before crash",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n)",
    "Upper Bound Reference": "https://dl.acm.org/doi/pdf/10.1145/128765.128770",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 149,
    "Family Name": "Recovery",
    "Variation": "No-Steal, Force",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Recovery is the process of reverting back to a safe state prior to a system failure.\n\nWith a No-Steal/Force policy, the recovery algorithm will never write uncommited data to memory, but will force all commits to memory.",
    "Description Reference": "https://dsf.berkeley.edu/jmh/cs186/f02/lecs/lec25_6up.pdf",
    "Parameters": "$n$: number of transactions before crash",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Operating Systems",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 153,
    "Family Name": "Link Analysis",
    "Variation": "Link Analysis",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Unlike \"flat\" document collections, the World Wide Web is hypertext and provides considerable auxiliary information on top of the text of the web pages, such as link structure and link text. With link analysis, we take advantage of the link structure of the Web to produce a global \"importance\" ranking of every web page that helps search engines and users quickly make sense of the vast heterogeneity of the World Wide Web.",
    "Description Reference": "http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf",
    "Parameters": "$n$: number of pages\n$m$: number of hyperlinks\n$z$: # of topics/categories",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "http://snap.stanford.edu/class/cs224w-readings/borodin05pagerank.pdf",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 7.5,
    "Family Name": "Graph Coloring",
    "Variation": "k-Graph Coloring",
    "Alias": "",
    "Parents": "",
    "Children": "2-Graph Coloring; 3-Graph Coloring; 4-Graph Coloring; 5-Graph Coloring; #k-Graph Coloring;",
    "Problem Description": "Graph coloring is a special case of graph labeling; it is an assignment of labels traditionally called \"colors\" to elements of a graph subject to certain constraints. In this case, the number of colors we have is given as an input.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0166218X96000960/pdf?md5=0a6c305277dd00a5e798cf731f79731e&pid=1-s2.0-0166218X96000960-main.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: number of colors given to color the graph",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n*poly(n))",
    "Upper Bound Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4031392",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "NP-hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 7.5,
    "Family Name": "Graph Coloring",
    "Variation": "Minimal Coloring",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Find coloring that minimizes number of colors",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 7.5,
    "Family Name": "Graph Coloring",
    "Variation": "small#-Graph Coloring",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Find coloring that minimizes number of colors to some reasonably small number? Probably somewhat heuristic, (would be great if they specified how approximate to chromatic number they get but i dont think they mostly do) ???",
    "Description Reference": "",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 7.5,
    "Family Name": "Graph Coloring",
    "Variation": "Chromatic Number",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In this case, we wish to compute the chromatic number of a graph; that is, the smallest number of colors needed to color the graph.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0166218X96000960/pdf?md5=0a6c305277dd00a5e798cf731f79731e&pid=1-s2.0-0166218X96000960-main.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n*poly(n))",
    "Upper Bound Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4031392",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "NP-hard",
    "Domain": "Combinatorics",
    "": "Possibly good survey: https://www.cambridge.org/core/books/topics-in-chromatic-graph-theory/graph-colouring-algorithms/0057166BDF05B304D0D81D6C1EB911B6",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 7.5,
    "Family Name": "Graph Coloring",
    "Variation": "2-Graph Coloring",
    "Alias": "",
    "Parents": "k-Graph Coloring",
    "Children": "",
    "Problem Description": "In this case, we wish to determine whether or not a graph is 2-colorable.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0166218X96000960/pdf?md5=0a6c305277dd00a5e798cf731f79731e&pid=1-s2.0-0166218X96000960-main.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(m+n)",
    "Upper Bound Reference": "Any graph traversal algorithm",
    "Best Known Lower Bound": "Omega(m+n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 7,
    "Family Name": "Graph Coloring",
    "Variation": "3-Graph Coloring",
    "Alias": "",
    "Parents": "k-Graph Coloring",
    "Children": "",
    "Problem Description": "In this case, we wish to determine whether or not a graph is 3-colorable.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0166218X96000960/pdf?md5=0a6c305277dd00a5e798cf731f79731e&pid=1-s2.0-0166218X96000960-main.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(1.3289^n)",
    "Upper Bound Reference": "https://www.sciencedirect.com/science/article/pii/S0196677404001117?via%3Dihub",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "NP-hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": 8,
    "Family Name": "Graph Coloring",
    "Variation": "4-Graph Coloring",
    "Alias": "",
    "Parents": "k-Graph Coloring",
    "Children": "",
    "Problem Description": "In this case, we wish to determine whether or not a graph is 4-colorable.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0166218X96000960/pdf?md5=0a6c305277dd00a5e798cf731f79731e&pid=1-s2.0-0166218X96000960-main.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(1.7272^n)",
    "Upper Bound Reference": "https://link.springer.com/chapter/10.1007/978-3-540-73545-8_9",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "NP-hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Coloring",
    "Variation": "5-Graph Coloring",
    "Alias": "",
    "Parents": "k-Graph Coloring",
    "Children": "",
    "Problem Description": "In this case, we wish to determine whether or not a graph is 5-colorable.",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/0166218X96000960/pdf?md5=0a6c305277dd00a5e798cf731f79731e&pid=1-s2.0-0166218X96000960-main.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O((2-eps)^n) for some eps>0",
    "Upper Bound Reference": "https://drops.dagstuhl.de/opus/volltexte/2021/14182/pdf/LIPIcs-ICALP-2021-113.pdf",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "NP-hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Coloring",
    "Variation": "#k-Graph Coloring",
    "Alias": "Chromatic Polynomial",
    "Parents": "k-Graph Coloring",
    "Children": "#2-Graph Coloring; #3-Graph Coloring; #4-Graph Coloring; #5-Graph Coloring;",
    "Problem Description": "In this case, the number of colors we have is given as an input, and we want to determine the number of all possible k-colorings of a graph. In other words, calculate the value of the chromatic polynomial of the graph with input k.",
    "Description Reference": "http://web.cs.elte.hu/blobs/diplomamunkak/mat/2009/hubai_tamas.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: number of colors given to color the graph",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n*poly(n))",
    "Upper Bound Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4031392",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "#P-hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Coloring",
    "Variation": "#2-Graph Coloring",
    "Alias": "",
    "Parents": "#k-Graph Coloring",
    "Children": "",
    "Problem Description": "In this case, we wish to determine the number of all possible 2-colorings of a graph.",
    "Description Reference": "http://web.cs.elte.hu/blobs/diplomamunkak/mat/2009/hubai_tamas.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(m+n)",
    "Upper Bound Reference": "Any graph traversal algorithm",
    "Best Known Lower Bound": "Omega(m+n)",
    "Lower Bound Reference": "Easily derived",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Coloring",
    "Variation": "#3-Graph Coloring",
    "Alias": "",
    "Parents": "#k-Graph Coloring",
    "Children": "",
    "Problem Description": "In this case, we wish to determine the number of all possible 3-colorings of a graph.",
    "Description Reference": "http://web.cs.elte.hu/blobs/diplomamunkak/mat/2009/hubai_tamas.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(1.6262^n)",
    "Upper Bound Reference": "https://link.springer.com/chapter/10.1007/978-3-540-73545-8_9",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "#P-hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Coloring",
    "Variation": "#4-Graph Coloring",
    "Alias": "",
    "Parents": "#k-Graph Coloring",
    "Children": "",
    "Problem Description": "In this case, we wish to determine the number of all possible 4-colorings of a graph.",
    "Description Reference": "http://web.cs.elte.hu/blobs/diplomamunkak/mat/2009/hubai_tamas.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(1.9464^n)",
    "Upper Bound Reference": "https://link.springer.com/chapter/10.1007/978-3-540-73545-8_9",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "#P-hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Coloring",
    "Variation": "#5-Graph Coloring",
    "Alias": "",
    "Parents": "#k-Graph Coloring",
    "Children": "",
    "Problem Description": "In this case, we wish to determine the number of all possible 5-colorings of a graph.",
    "Description Reference": "http://web.cs.elte.hu/blobs/diplomamunkak/mat/2009/hubai_tamas.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(2^n*poly(n))",
    "Upper Bound Reference": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4031392",
    "Best Known Lower Bound": "Omega(poly(n))",
    "Lower Bound Reference": "#P-hard",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "SAT",
    "Alias": "Boolean Satisfiability",
    "Parents": "",
    "Children": "Conjunctive Normal Form SAT; Disjunctive Normal Form SAT;",
    "Problem Description": "Boolean satisfiability problems involve determining if there is an assignment of variables that satisfies a given boolean formula.",
    "Description Reference": "https://eprints.soton.ac.uk/265340/1/jpms-wodes08.pdf",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(n))",
    "Lower Bound Reference": "Cook-Levin Theorem",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Conjunctive Normal Form SAT",
    "Alias": "CNF-SAT",
    "Parents": "SAT",
    "Children": "All-Equal-SAT; k-SAT; XOR-SAT; Horn SAT; MaxSAT;",
    "Problem Description": "CNF-SAT restricts the boolean formula to conjunctive normal form (CNF), meaning it is the AND of ORs.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2925416",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(n))",
    "Lower Bound Reference": "Cook-Levin Theorem",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Disjunctive Normal Form SAT",
    "Alias": "DNF-SAT",
    "Parents": "SAT",
    "Children": "",
    "Problem Description": "DNF-SAT restricts the boolean formula to disjunctive normal form (DNF), meaning it is the OR of ANDs.",
    "Description Reference": "https://link.springer.com/content/pdf/10.1007/BF00996269.pdf",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "\\poly(n)",
    "Upper Bound Reference": "Trivial--only need one clause to be satisfied",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "1-in-3SAT",
    "Alias": "",
    "Parents": "3SAT",
    "Children": "Monotone 1-in-3SAT; Monotone Not-Exactly-1-in-3SAT;",
    "Problem Description": "1-in-3SAT restricts the boolean formula to CNF with 3 literals per clause and determines whether there is an assignment of variables such that exactly 1 of the 3 literals in each clause is TRUE",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/800133.804350",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(n))",
    "Lower Bound Reference": "Schaefer 1978",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Monotone 1-in-3SAT",
    "Alias": "",
    "Parents": "1-in-3SAT",
    "Children": "",
    "Problem Description": "Monotone 1-in-3SAT is 1-in-3SAT with the restriction that all of the literals in a clause are all positive (note: here, we don't allow clauses to be all negated literals)",
    "Description Reference": "https://drops.dagstuhl.de/opus/volltexte/2016/6476/pdf/LIPIcs-MFCS-2016-64.pdf",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(n))",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Monotone Not-Exactly-1-in-3SAT",
    "Alias": "",
    "Parents": "1-in-3SAT",
    "Children": "",
    "Problem Description": "Monotone Not-Exactly-1-in-3SAT is Monotone 1-in-3SAT, except that rather than exactly one variable in a clause being true, it requires exactly 0, 2, or 3 of the variables in a clause being true",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/S1572528613000030",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "\\poly(n)",
    "Upper Bound Reference": "Schaefer 1978",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "All-Equal-SAT",
    "Alias": "",
    "Parents": "Conjunctive Normal Form SAT",
    "Children": "",
    "Problem Description": "All-Equal-SAT restricts the boolean formula to CNF and determines whether there is an assignment of variables such that, for all of the clauses, all literals have the same boolean value",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/800133.804350",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Not-All-Equal 3-SAT (NAE 3SAT)",
    "Alias": "",
    "Parents": "3SAT",
    "Children": "Monotone Not-All-Equal 3-SAT (Monotone NAE 3SAT);",
    "Problem Description": "NAE 3SAT restricts the boolean formula to CNF with 3 literals per clause and determines whether there is an assignment of variables such that, for none of the clauses, all 3 literals have the same boolean value",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/800133.804350",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(n))",
    "Lower Bound Reference": "Schaefer 1978",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Monotone Not-All-Equal 3-SAT (Monotone NAE 3SAT)",
    "Alias": "",
    "Parents": "Not-All-Equal 3-SAT (NAE 3SAT)",
    "Children": "",
    "Problem Description": "Monotone NAE 3SAT is NAE 3SAT with the restriction that all of the literals in a clause are either all negated or all positive",
    "Description Reference": "https://doi.org/10.1016/j.tcs.2020.02.010",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(n))",
    "Lower Bound Reference": "Schaefer 1978",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "k-SAT",
    "Alias": "",
    "Parents": "Conjunctive Normal Form SAT",
    "Children": "2SAT; 3SAT; 4SAT;",
    "Problem Description": "k-SAT restricts the boolean formula to CNF with (at most) k literals per clause",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3491210?casa_token=9ge17j5R2vAAAAAA:Ex4kBr0hTUo_VEVlcFUJgW3zwfdyUhGW6VyV6IxDUq9eJbxBMa8GPx0dv-AR8xyuyCKk6uie8To",
    "Parameters": "$n$: number of variables\n$k$: max number of literals per clause\n$c$: dependant on $k$",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(c^n)",
    "Upper Bound Reference": "PPSZ Algorithm",
    "Best Known Lower Bound": "\\Omega(2^n)",
    "Lower Bound Reference": "SETH",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "2SAT",
    "Alias": "2-SAT",
    "Parents": "k-SAT",
    "Children": "",
    "Problem Description": "2SAT restricts the boolean formula to CNF with (at most) 2 literals per clause",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3491210?casa_token=9ge17j5R2vAAAAAA:Ex4kBr0hTUo_VEVlcFUJgW3zwfdyUhGW6VyV6IxDUq9eJbxBMa8GPx0dv-AR8xyuyCKk6uie8To",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "$O(n^2)$",
    "Upper Bound Reference": "Trivial--Check each x_i and follow implications",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "3SAT",
    "Alias": "3-SAT",
    "Parents": "k-SAT",
    "Children": "1-in-3SAT; Not-All-Equal 3-SAT (NAE 3SAT); 3SAT-5; Monotone 3SAT;",
    "Problem Description": "3SAT restricts the boolean formula to CNF with (at most) 3 literals per clause",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3491210?casa_token=9ge17j5R2vAAAAAA:Ex4kBr0hTUo_VEVlcFUJgW3zwfdyUhGW6VyV6IxDUq9eJbxBMa8GPx0dv-AR8xyuyCKk6uie8To",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(1.308^n) (Randomized)",
    "Upper Bound Reference": "Hertli 2014",
    "Best Known Lower Bound": "\\Omega(2^n)",
    "Lower Bound Reference": "SETH",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "3SAT-5",
    "Alias": "3-SAT-5",
    "Parents": "3SAT",
    "Children": "",
    "Problem Description": "3SAT-5 is 3SAT with the restriction that each variable occurs in at most 5 clauses",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/237814.237977",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(n))",
    "Lower Bound Reference": "Feige-JACM 1998",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "4SAT",
    "Alias": "4-SAT",
    "Parents": "k-SAT",
    "Children": "",
    "Problem Description": "4SAT restricts the boolean formula to CNF with (at most) 4 literals per clause",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3491210?casa_token=9ge17j5R2vAAAAAA:Ex4kBr0hTUo_VEVlcFUJgW3zwfdyUhGW6VyV6IxDUq9eJbxBMa8GPx0dv-AR8xyuyCKk6uie8To",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(1.469^n) (Randomized)",
    "Upper Bound Reference": "Hertli 2014",
    "Best Known Lower Bound": "\\Omega(2^n)",
    "Lower Bound Reference": "SETH",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Monotone 3SAT",
    "Alias": "",
    "Parents": "3SAT",
    "Children": "",
    "Problem Description": "Monotone 3SAT is 3SAT with the restriction that all of the literals in a clause are either all negated or all positive",
    "Description Reference": "https://iccl.inf.tu-dresden.de/w/images/9/9d/Brandt-ECAI-2004.pdf",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega(\\poly(n))",
    "Lower Bound Reference": "Gold-I&C 1978",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "XOR-SAT",
    "Alias": "",
    "Parents": "Conjunctive Normal Form SAT",
    "Children": "",
    "Problem Description": "XOR-SAT replaces the ORs in CNF with XORs",
    "Description Reference": "https://doi.org/10.1016/S0166-218X(99)00032-3",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^3)",
    "Upper Bound Reference": "Gaussian Elimination",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Horn SAT",
    "Alias": "",
    "Parents": "Conjunctive Normal Form SAT",
    "Children": "Dual-Horn SAT; Renamable Horn;",
    "Problem Description": "Horn SAT restricts the boolean formula to the conjunction of Horn clauses, i.e. clauses with at most one positive literal",
    "Description Reference": "https://doi.org/10.1016/0743-1066(84)90014-1",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "\\poly(n)",
    "Upper Bound Reference": "Horn 1951",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Dual-Horn SAT",
    "Alias": "",
    "Parents": "Horn SAT",
    "Children": "",
    "Problem Description": "Dual-Horn SAT restricts the boolean formula to the conjunction of dual-Horn clauses, i.e. clauses with at most one negated literal",
    "Description Reference": "https://www.sciencedirect.com/science/article/pii/S0304397519300076?via%3Dihub",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "\\poly(n)",
    "Upper Bound Reference": "Schaefer 1978",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "Renamable Horn",
    "Alias": "",
    "Parents": "Horn SAT",
    "Children": "",
    "Problem Description": "Renamable Horn asks the question whether or not there exists a subset of variables that can be negated such that the boolean formula is turned into a Horn formula",
    "Description Reference": "https://doi.org/10.1145%2F322047.322059",
    "Parameters": "$n$: number of variables\n$m$: number of clauses",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(mn^2)",
    "Upper Bound Reference": "Lewis 1978",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Boolean Satisfiability",
    "Variation": "MaxSAT",
    "Alias": "MAX-CNF-SAT",
    "Parents": "Conjunctive Normal Form SAT",
    "Children": "",
    "Problem Description": "Given an instance of SAT represented in Conjunctive Normal Form (CNF), compute an assignment to the variables that maximizes the number of satisfied clauses.",
    "Description Reference": "https://eprints.soton.ac.uk/265340/1/jpms-wodes08.pdf",
    "Parameters": "$n$: number of variables",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Orthogonal Vectors",
    "Variation": "OV",
    "Alias": "2-OV",
    "Parents": "k-OV",
    "Children": "Unbalanced OV;",
    "Problem Description": "Given $n$ vectors in $\\{0,1\\}^{O(\\log n)}$, are two of them orthogonal?",
    "Description Reference": "https://epubs.siam.org/doi/epdf/10.1137/1.9781611975482.2",
    "Parameters": "$n$: number of vectors\n$d$: dimension of each vector; $d = O(log(n))$ typically",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "$O(n^{2-1/O(d/log(n)))})$",
    "Upper Bound Reference": "https://epubs.siam.org/doi/abs/10.1137/1.9781611974331.ch87",
    "Best Known Lower Bound": "\\Omega(n^{2-o(1)})",
    "Lower Bound Reference": "2-OV Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Orthogonal Vectors",
    "Variation": "k-OV",
    "Alias": "",
    "Parents": "",
    "Children": "OV; 3-OV;",
    "Problem Description": "Given $k$ sets of $d$-dimensional vectors $A_1, A_2, \\ldots, A_k$, each of size $n$, does there exist $a_1 \\in A_1, a_2 \\in A_2, \\ldots, a_k \\in A_k$ such that $a_1 * a_2 * \\ldots * a_k = 0$?",
    "Description Reference": "https://drops.dagstuhl.de/opus/volltexte/2018/9031/pdf/LIPIcs-ICALP-2018-27.pdf",
    "Parameters": "$n$: number of vectors per set\n$k$: number of sets\n$d$: dimension of each vector; $d = omega(log(n))$",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "$O(n^{k-1/O(d/log(n)))})$",
    "Upper Bound Reference": "https://epubs.siam.org/doi/abs/10.1137/1.9781611974331.ch87",
    "Best Known Lower Bound": "\\Omega(n^{k-o(1)})",
    "Lower Bound Reference": "k-OV Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Orthogonal Vectors",
    "Variation": "3-OV",
    "Alias": "",
    "Parents": "k-OV",
    "Children": "",
    "Problem Description": "Given 3 sets of $d$-dimensional vectors $A_1, A_2, A_3$, each of size $n$, does there exist $a_1 \\in A_1, a_2 \\in A_2, a_3 \\in A_3$ such that $a_1 * a_2 * a_3 = 0$?",
    "Description Reference": "https://drops.dagstuhl.de/opus/volltexte/2018/9031/pdf/LIPIcs-ICALP-2018-27.pdf",
    "Parameters": "$n$: number of vectors per set\n$d$: dimension of each vector; $d = omega(log(n))$",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "$O(n^{3-1/O(d/log(n)))})$",
    "Upper Bound Reference": "https://epubs.siam.org/doi/abs/10.1137/1.9781611974331.ch87",
    "Best Known Lower Bound": "\\Omega(n^{3-o(1)})",
    "Lower Bound Reference": "3-OV Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Orthogonal Vectors",
    "Variation": "Unbalanced OV",
    "Alias": "UOV",
    "Parents": "OV",
    "Children": "",
    "Problem Description": "Let $0 < \\alpha \\leq 1$. UOV is the OV problem with the specifications that $A$ is of size $n$ and $B$ is of size $m=\\Theta(n^\\alpha)$ and $d\\leq n^{o(1)}$.",
    "Description Reference": "https://arxiv.org/pdf/1502.01063.pdf",
    "Parameters": "$n$: size of $A$\n$m$: size of $B$\n$d$: dimensionality of vectors",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "\\Omega((nm)^{(1-\\epsilon)})",
    "Lower Bound Reference": "UOVH",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "Median",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, determine the median $m$ of the graph, where $m := \\min\\limits_{v\\in V} \\sum\\limits_{u\\in V} d(u, v)$",
    "Description Reference": "https://doi.org/10.1016/0378-8733(94)00248-9",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "Radius",
    "Alias": "",
    "Parents": "Eccentricity",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, determine the radius $r$ of the graph, i.e. the minimum eccentricity over all of the vertices of the graph",
    "Description Reference": "https://doi.org/10.1016/0378-8733(94)00248-9",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "Diameter",
    "Alias": "",
    "Parents": "Eccentricity",
    "Children": "Approximate Diameter; Decremental Diameter;",
    "Problem Description": "Given a graph $G = (V, E)$, determine the diameter $d$ of the graph, i.e. the maximum eccentricity over all of the vertices of the graph",
    "Description Reference": "https://doi.org/10.1016/0378-8733(94)00248-9",
    "Parameters": "$V$: number of vertices\n$E$: number of edges",
    "Parameter for graphs": "V",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "<= has variants",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "Diameter 2 vs 3",
    "Alias": "4/3-Diameter",
    "Parents": "Approximate Diameter",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, distinguish between diameter 2 and diameter 3. In other words, approximate diameter within a factor of $4/3-\\epsilon$.",
    "Description Reference": "https://people.csail.mit.edu/virgi/diam.pdf",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "Diameter 3 vs 7",
    "Alias": "",
    "Parents": "Approximate Diameter",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, distinguish between diameter 3 and diameter 7. In other words, approximate diameter within a factor of $9/4-\\epsilon$.",
    "Description Reference": "https://people.csail.mit.edu/virgi/diam.pdf",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "Approximate Diameter",
    "Alias": "",
    "Parents": "Diameter",
    "Children": "Diameter 2 vs 3; Diameter 3 vs 7;",
    "Problem Description": "Given a graph $G = (V, E)$, approximate the diameter within a given factor.",
    "Description Reference": "https://people.csail.mit.edu/virgi/diam.pdf",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "Decremental Diameter",
    "Alias": "",
    "Parents": "Diameter",
    "Children": "1-sensitive decremental diameter; constant sensitivity (4/3)-approximate incremental diameter;",
    "Problem Description": "Determine the diameter of a graph decrementally, i.e. by removing edges and querying the resulting graph.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "1-sensitive (4/3)-approximate decremental diameter",
    "Alias": "",
    "Parents": "1-sensitive decremental diameter",
    "Children": "",
    "Problem Description": "Approximate the diameter of a graph decrementally within a factor of 4/3, with a sensativity of 1, i.e. when a single edge is removed.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "1-sensitive decremental diameter",
    "Alias": "",
    "Parents": "Decremental Diameter",
    "Children": "1-sensitive (4/3)-approximate decremental diameter;",
    "Problem Description": "Determine the diameter of a graph decrementally, with a sensativity of 1, i.e. when a single edge is removed.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "constant sensitivity (4/3)-approximate incremental diameter",
    "Alias": "",
    "Parents": "Decremental Diameter",
    "Children": "",
    "Problem Description": "Approximate the diameter of a graph decrementally within a factor of 4/3, with a constant sensitivity of $K(\\epsilon, t)$, i.e. when a $K(\\epsilon, t)$ edges are removed.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Metrics",
    "Variation": "1-sensitive (4/3)-approximate decremental eccentricity",
    "Alias": "",
    "Parents": "Eccentricity",
    "Children": "",
    "Problem Description": "Approximate the eccentricity of a graph decrementally within a factor of 4/3, with a sensativity of 1, i.e. when a single edge is removed.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Eccentricity",
    "Alias": "",
    "Parents": "",
    "Children": "Radius; Diameter; 1-sensitive (4/3)-approximate decremental eccentricity;",
    "Problem Description": "Given a graph $G = (V, E)$ and a vertex $v \\in V$, calculate the eccentricity $\\epsilon(v) := \\max \\limits_{u\\in V} d(u, v)$",
    "Description Reference": "https://doi.org/10.1016/0378-8733(94)00248-9",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "All-Nodes Median Parity",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$, compute $Med(v) (\\mod 2)$ for all $v\\in V$, where $Med(v) := \\sum\\limits_{w\\in V} d(v, w)$",
    "Description Reference": "https://epubs.siam.org/doi/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Betweenness Centrality",
    "Alias": "BC",
    "Parents": "",
    "Children": "Approximate Betweenness Centrality; Positive Betweenness Centrality;",
    "Problem Description": "Given a graph $G = (V, E)$ and a vertex $v \\in V$, calculate the betweenness centrality of vertex $v$ (or the proportion of shortest paths that go through $v$), i.e. $BC(v) := \\sum\\limits_{s\\neq t \\neq v \\in V} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$ where $\\sigma_{st}(v)$ is the number of shortest paths from $s$ to $t$ that go through $v$ and $\\sigma_{st}$ is the number of shortest paths from $s$ to $t$.",
    "Description Reference": "https://doi.org/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Approximate Betweenness Centrality",
    "Alias": "",
    "Parents": "Betweenness Centrality",
    "Children": "",
    "Problem Description": "Given a graph $G = (V, E)$ and a vertex $v \\in V$, approximate the betweenness centrality of vertex $v$",
    "Description Reference": "https://epubs.siam.org/doi/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Positive Betweenness Centrality",
    "Alias": "",
    "Parents": "Betweenness Centrality",
    "Children": "Directed All-Nodes Positive Betweenness Centrality; Undirected All-Nodes Positive Betweenness Centrality;",
    "Problem Description": "Given a graph $G=(V,E)$ and a vertex $v \\in V$, determine whether the betweenness centrality of $v$ is positive.",
    "Description Reference": "https://doi.org/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Directed All-Nodes Positive Betweenness Centrality",
    "Alias": "",
    "Parents": "Positive Betweenness Centrality",
    "Children": "",
    "Problem Description": "Given a directed graph, determine whether the betweenness centrality of all nodes is positive.",
    "Description Reference": "https://doi.org/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Undirected All-Nodes Positive Betweenness Centrality",
    "Alias": "",
    "Parents": "Positive Betweenness Centrality",
    "Children": "",
    "Problem Description": "Given an undirected graph, determine whether the betweenness centrality of all nodes is positive.",
    "Description Reference": "https://doi.org/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Reach Centrality",
    "Alias": "",
    "Parents": "",
    "Children": "Directed All-Nodes Reach Centrality; Undirected All-Nodes Reach Centrality; Approximate Reach Centrality;",
    "Problem Description": "The reach centrality of a node $w$ is the smallest distance $r$ such that any $s-t$ shortest path passing through $w$ has either $s$ or $t$ in the ball of radius $r$ around $w$.",
    "Description Reference": "https://epubs.siam.org/doi/epdf/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Directed All-Nodes Reach Centrality",
    "Alias": "",
    "Parents": "Reach Centrality",
    "Children": "",
    "Problem Description": "The reach centrality of a node $w$ is the smallest distance $r$ such that any $s-t$ shortest path passing through $w$ has either $s$ or $t$ in the ball of radius $r$ around $w$.\n\nDirected All-Nodes Reach Centrality is the version of the problem in a directed graph where you must calculate the reach centrality of each node.",
    "Description Reference": "https://epubs.siam.org/doi/epdf/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Undirected All-Nodes Reach Centrality",
    "Alias": "",
    "Parents": "Reach Centrality",
    "Children": "",
    "Problem Description": "The reach centrality of a node $w$ is the smallest distance $r$ such that any $s-t$ shortest path passing through $w$ has either $s$ or $t$ in the ball of radius $r$ around $w$.\n\nUndirected All-Nodes Reach Centrality is the version of the problem in an undirected graph where you must calculate the reach centrality of each node.",
    "Description Reference": "https://epubs.siam.org/doi/epdf/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Centrality",
    "Variation": "Approximate Reach Centrality",
    "Alias": "",
    "Parents": "Reach Centrality",
    "Children": "",
    "Problem Description": "The reach centrality of a node $w$ is the smallest distance $r$ such that any $s-t$ shortest path passing through $w$ has either $s$ or $t$ in the ball of radius $r$ around $w$.\n\nApproximate reach centrality is the approximation version of the problem.",
    "Description Reference": "https://epubs.siam.org/doi/epdf/10.1137/1.9781611973730.112",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Triangle Problems",
    "Variation": "Negative Triangle Detection",
    "Alias": "",
    "Parents": "Triangle Detection",
    "Children": "Negative Triangle Search;",
    "Problem Description": "Given an $n$ node graph $G = (V, E)$ with edge weights $w: E \\rightarrow W$, determine whether there is a negative triangle, i.e. three vertices that form a triangle with total edge weights summing to a negative number.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Triangle Problems",
    "Variation": "Negative Triangle Search",
    "Alias": "",
    "Parents": "Negative Triangle Detection",
    "Children": "Negative Triangle Listing;",
    "Problem Description": "Given an $n$ node graph $G = (V, E)$ with edge weights $w: E \\rightarrow W$, find a negative triangle, i.e. three vertices that form a triangle with total edge weights summing to a negative number.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Triangle Problems",
    "Variation": "Negative Triangle Listing",
    "Alias": "",
    "Parents": "Negative Triangle Search",
    "Children": "",
    "Problem Description": "Given an $n$ node graph $G = (V, E)$ with edge weights $w: E \\rightarrow W$, list the negative triangles, i.e. three vertices that form a triangle with total edge weights summing to a negative number.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Triangle Problems",
    "Variation": "Nondecreasing Triangle",
    "Alias": "",
    "Parents": "Triangle Detection",
    "Children": "",
    "Problem Description": "Given a tripartite graph with partitions $I, J, K$ and real edge weights, find a triangle $i \\in I, j \\in J, k \\in K$ such that $w(i, k) \\leq w(k, j) \\leq w(i, j)$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Triangle Problems",
    "Variation": "Minimum Triangle",
    "Alias": "",
    "Parents": "Triangle Detection",
    "Children": "",
    "Problem Description": "Find the triangle in a graph with minimum weight",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Triangle Problems",
    "Variation": "Triangle in Unweighted Graph",
    "Alias": "",
    "Parents": "Triangle Detection",
    "Children": "",
    "Problem Description": "Find a triangle in an unweighted graph",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Triangle Problems",
    "Variation": "Triangle Detection",
    "Alias": "",
    "Parents": "",
    "Children": "Negative Triangle Detection; Nondecreasing Triangle; Minimum Triangle; Triangle in Unweighted Graph; Triangle Collection*;",
    "Problem Description": "Determine whether or not there is a triangle in a given graph",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Triangle Problems",
    "Variation": "Triangle Collection*",
    "Alias": "TC*",
    "Parents": "Triangle Detection",
    "Children": "",
    "Problem Description": "See Definition 3 of reference.",
    "Description Reference": "https://arxiv.org/abs/1602.06705",
    "Parameters": "$n$: number of nodes\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Metricity",
    "Variation": "Metricity",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given an $n\\times n$ nonnegative matrix $A$, determine whether $A$ defines a metric on $[n]$, that is, that A is symmetric, has 0s on the diagonal, and its entries satisfy the triangle inequality.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: dimensionality of matrix",
    "Parameter for graphs": "n^2",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Frechet Distance",
    "Variation": "Frechet Distance",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Intuitively, the (continuous) Fréchet distance of two curves $P, Q$ is the minimal length of a leash required to connect a dog to its owner, as they walk along $P$ or $Q$, respectively, without backtracking.",
    "Description Reference": "https://people.mpi-inf.mpg.de/~kbringma/paper/2014FOCS.pdf",
    "Parameters": "$n$: length of first curve\n$m$: length of second curve",
    "Parameter for graphs": "m,n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Dynamic Time Warping",
    "Variation": "Dynamic Time Warping",
    "Alias": "DTW",
    "Parents": "",
    "Children": "",
    "Problem Description": "Fix a metric space $(M, d)$. A sequence of points in $M$ is called a curve. Consider two curves $x, y$ of length $n, m (n \\geq m)$. We may traverse $x$ and $y$ by starting in their first entries, in any time step advancing to the next entry in $x$ or $y$ or both, and ending in their last entries. The cost of such a traversal is the sum over all points in time of the distance between the current entries. The dynamic time warping distance of $x$ and $y$ is the minimal cost of any traversal.",
    "Description Reference": "https://arxiv.org/pdf/1502.01063.pdf",
    "Parameters": "$n$: length of first curve\n$m$: length of second curve",
    "Parameter for graphs": "m,n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Partial Match",
    "Variation": "Partial Match",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In the Partial Match problem, we are given a \"database\" of $n$ binary strings, and a list of $n$ \"queries\" which are strings in $\\{0,1,?\\}^*$. (Here, \"?\" represents a wildcard.) We say that a query $q=q_1,...,q_d$ matches a string $x=x_1,...,x_d$ if for all $i=1,...,d$, if $q_i$ in $\\{0,1\\}$ then $q_i = x_i$.\nOutput: Determine for all $n$ queries, which of them match some string in the database.",
    "Description Reference": "https://people.csail.mit.edu/virgi/6.s078/lecture6-post.txt",
    "Parameters": "$n$: number of binary strings/queries\n$d$: length of strings/queries",
    "Parameter for graphs": "nd",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "$\\Omega(n^{2-\\epsilon}*\\poly(d))$",
    "Lower Bound Reference": "Reduction #9",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Incidence Problems",
    "Variation": "3 Points on Line",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of points in the plane, is there a line that contains at least three of the points?",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of points",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Incidence Problems",
    "Variation": "Point on 3 Lines",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of lines in the plane, is there a point that lies on at least three of them?",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of lines",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Separator Problems",
    "Variation": "Separator1",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set $S$ of $n$ possible half-infinite, closed horizontal line segments, is there a non-horizontal separator?\n\nSeparator definition: Given a set $S$ of $n$ objects in the plane, we call a line $l$ a separator of $S$ if $l$ does not intersect any object in $S$ and both halfplanes bounded by $l$ contain a non-empty subset of the objects in $S$.",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of line segments",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Separator Problems",
    "Variation": "Separator2",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set $S$ of $n$ closed, non-intersecting (nor touching), axis-parallel line segments, is there a separator?",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of line segments",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Covering Problems",
    "Variation": "Strips Cover Box",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of strips in the plane, does their union contain a given axis-parallel rectangle?",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of strips",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Covering Problems",
    "Variation": "Triangles Cover Triangle",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of triangles in the plane, does their union contain another given triangle?",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of triangles",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Covering Problems",
    "Variation": "Hole in Union",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of triangles in the plane, does their union contain a hole?",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of triangles",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Covering Problems",
    "Variation": "Triangle Measure",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of triangles in the plane, compute the measure of their union.",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of triangles",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Covering Problems",
    "Variation": "Point Covering",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of $n$ halfplanes and a number $k$, determine whether there is a point $p$ that is covered by at least $k$ of the halfplanes.",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of halfplanes",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Covering Problems",
    "Variation": "Max-Weight Rectangle",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given $n$ weighted points (positive or negative) in $d \\geq 2$ dimensions, what is the axis-aligned box which maximizes the total weight of the points it contains?",
    "Description Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Parameters": "$n$: number of points\n$d$: dimensionality of space",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^d)",
    "Upper Bound Reference": "https://doi.org/10.1016/j.ipl.2014.03.007",
    "Best Known Lower Bound": "\\Omega(n^d)",
    "Lower Bound Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Covering Problems",
    "Variation": "Weighted Depth",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of $n$ weighted axis-parallel boxes in $d$-dimensional space $\\mathbb{R}^d$, find a point $p \\in \\mathbb{R}^d$ that maximizes the sum of the weights of the boxes containing $p$.",
    "Description Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Parameters": "$n$: number of boxes\n$d$: dimensionality of space",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^{d/2})",
    "Upper Bound Reference": "https://doi.org/10.1109/FOCS.2013.51",
    "Best Known Lower Bound": "\\Omega(n^{d/2})",
    "Lower Bound Reference": "https://arxiv.org/pdf/1602.05837.pdf",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Visibility Problems",
    "Variation": "Visibility Between Segments",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set $S$ of $n$ horizontal line segments in the plane and two particular horizontal segments $s_1$ and $s_2$, determine whether there are points on $s_1$ and $s_2$ that can see each other, that is, such that the open segment between the points does not intersect any segment in $S$.",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of horizontal line segments",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Visibility Problems",
    "Variation": "Visibility From Infinity",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set $S$ of axis-parallel line segments in the plane and one particular horizontal segments $s$, determine whether there is a point on $s$ that can be seen from infinity, that is, whether there exists an infinite ray starting at the point on $s$ that does not intersect any segment.",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of axis-parallel line segments",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Visibility Problems",
    "Variation": "Visible Triangle",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set $S$ of opaque horizontal triangles, another horizontal triangle $t$ and a viewpoint $p$, is there a point on $t$ that can be seen from $p$?",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of opaque horizontal triangles",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Motion Planning Problems",
    "Variation": "Planar Motion Planning",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of non-intersecting, non-touching, axis-parallel line segment obstacles in the plane and a line segment robot (a rod or ladder), determine whether the rod can be moved (allowing both translation and rotation) from a given source to a given goal configuration without colliding with the obstacles.",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of line segment obstacles",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^2)",
    "Upper Bound Reference": "https://link.springer.com/content/pdf/10.1007/3-540-52846-6_81.pdf",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Motion Planning Problems",
    "Variation": "3D Motion Planning",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of horizontal (that is, parallel to the xy-plane) non-intersecting, non-touching triangle obstacles in 3-space, and a vertical line segment as a robot, determine whether the robot can be moved, using translations only, from a source to a goal position without colliding with the obstacles.",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of triangle obstacles",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^2 \\log n)",
    "Upper Bound Reference": "Y. Ke and J. O'Rourke, An algorithm for moving a ladder in three dimensions, 1987",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Robotics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Geometric Base",
    "Variation": "Geometric Base",
    "Alias": "GeomBase",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a set of $n$ points with integer coordinates on three horizontal lines $y = 0, y = 1$, and $y = 2$, determine whether there exists a non-horizontal line containing three of the points",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of points",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Computational Geometry",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Local Alignment",
    "Variation": "Local Alignment",
    "Alias": "",
    "Parents": "",
    "Children": "Multiple Local Alignment;",
    "Problem Description": "Given two input strings and a scoring function on pairs of letters, one is asked to find the substrings of the two input strings that are most similar under the scoring function.",
    "Description Reference": "https://link.springer.com/chapter/10.1007/978-3-662-43948-7_4",
    "Parameters": "$n$: length of input strings",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Local Alignment",
    "Variation": "Multiple Local Alignment",
    "Alias": "",
    "Parents": "Local Alignment",
    "Children": "",
    "Problem Description": "Given $k$ input strings and a scoring function on pairs of letters, one is asked to find the substrings of the $k$ input strings that are most similar under the scoring function.",
    "Description Reference": "https://link.springer.com/chapter/10.1007/978-3-662-43948-7_4",
    "Parameters": "$k$: number of input strings\n$n$: length of input strings",
    "Parameter for graphs": "kn",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Minimum Witness",
    "Variation": "Minimum Witness Finding",
    "Alias": "",
    "Parents": "",
    "Children": "All Pairs Minimum Witness;",
    "Problem Description": "Fix an instance of negative triangle with node sets $I, J, K$ and weight function $w$. Let $i \\in I, j \\in J, k \\in K$. Recall that the triple $(i, j, k)$ is a negative triangle iff $(w(i, k) \\odot w(k, j)) + w(i, j) < 0$. Fix a total ordering $<$ on the nodes in $K$ in the negative triangle instance. For any $i \\in I, j \\in J$, a node $k \\in K$ is called a minimum witness for $(i, j)$ if $(i, j, k)$ is a negative triangle but $(i, j, k')$ is not a negative triangle for all $k' < k$ according to the ordering.\n\nMinimum Witness Finding is the problem of finding a negative triangle $(i,j,k)$ such that $k$ is a minimum witness for $(i,j)$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Minimum Witness",
    "Variation": "All Pairs Minimum Witness",
    "Alias": "APMW",
    "Parents": "Minimum Witness Finding",
    "Children": "",
    "Problem Description": "Fix an instance of negative triangle with node sets $I, J, K$ and weight function $w$. Let $i \\in I, j \\in J, k \\in K$. Recall that the triple $(i, j, k)$ is a negative triangle iff $(w(i, k) \\odot w(k, j)) + w(i, j) < 0$. Fix a total ordering $<$ on the nodes in $K$ in the negative triangle instance. For any $i \\in I, j \\in J$, a node $k \\in K$ is called a minimum witness for $(i, j)$ if $(i, j, k)$ is a negative triangle but $(i, j, k')$ is not a negative triangle for all $k' < k$ according to the ordering.\n\nAll Pairs Minimum Witness (APMW) is the problem of finding a minimum witness $k$ for each pair $(i,k)$ if such a $k$ exists for $(i,j)$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Independent Set Queries",
    "Variation": "Independent Set Queries",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "For a graph $G=(V,E)$ and a given subset of vertices $S\\subseteq G$, answer the query of the form \"is $S$ an independent set?",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Price Query",
    "Variation": "Price Query",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "For a graph with edge weight function $c : E \\rightarrow Z$, a price query is an assignment of node weights $p : V \\rightarrow Z$. Such a query has a yes answer if and only if there is a $(u,v) \\in E$ such that $p(u) + p(v) > c(u,v)$. (Intuitively, the $p(v)$ are “prices” on the nodes, the $c(u,v)$ are costs of producing $u$ and $v$, and a price query asks if there is an edge we are willing to “sell” at the prices given by the query.)",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Cycles",
    "Variation": "Shortest Cycle",
    "Alias": "Minimum Weight Cycle",
    "Parents": "",
    "Children": "Shortest k-Cycle;",
    "Problem Description": "Given a graph $G=(V,E)$ with non-negative weights, find a minimum weight cycle.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Graph Cycles",
    "Variation": "Shortest k-Cycle",
    "Alias": "Minimum Weight k-Cycle",
    "Parents": "Shortest Cycle",
    "Children": "",
    "Problem Description": "Given a graph $G=(V,E)$ with non-negative weights, find a minimum weight cycle of length $k$.",
    "Description Reference": "https://arxiv.org/pdf/1712.08147v2.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$k$: length of cycle",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Matrix-Vector Multiplication",
    "Variation": "Online Matrix-Vector Multiplication",
    "Alias": "OMv",
    "Parents": "",
    "Children": "",
    "Problem Description": "We are given an $n \\times n$ matrix $M$ and will receive $n$ column-vectors of size $n$, denoted by $v_1, \\ldots , v_n$, one by one. After seeing each vector $v_i$, we have to output the product $Mv_i$ before we can see the next vector.",
    "Description Reference": "https://doi.org/10.1145/2746539.2746609",
    "Parameters": "$n$: dimension of square matrix, number of vectors, size of vectors",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^3 / (log n)^2) deterministic, O(n^3 / 2^(Omega(sqrt(log n)))) randomized",
    "Upper Bound Reference": "https://epubs.siam.org/doi/abs/10.1137/1.9781611974782.142",
    "Best Known Lower Bound": "$\\Omega(n^{3-\\epsilon})$ for any $\\epsilon > 0$",
    "Lower Bound Reference": "OMV Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Matrix-Vector Multiplication",
    "Variation": "Online Vector-Matrix-Vector Multiplication",
    "Alias": "OuMv",
    "Parents": "",
    "Children": "",
    "Problem Description": "Let $M$ be a binary $n \\times n$ matrix than can be preprocessed. After preprocessing $n$ vector pairs $(u^1, v^1), \\ldots, (u^n, v^n)$, arrive one at a time and the task is to compute $(u^i)^T M v^i$ before being presented with the $i+1$th vector pair for every $i$.",
    "Description Reference": "https://doi.org/10.1145/2746539.2746609",
    "Parameters": "$n$: dimension of square matrix, number of vector pairs, size of vectors",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "$\\Omega(n^{3-\\epsilon})$",
    "Lower Bound Reference": "https://arxiv.org/pdf/1602.06705.pdf",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Reachability",
    "Variation": "#SSR",
    "Alias": "",
    "Parents": "",
    "Children": "sensitive incremental #SSR;",
    "Problem Description": "Calculate the number of nodes reachable from a given single source",
    "Description Reference": "https://ieeexplore.ieee.org/abstract/document/6979028?casa_token=daaoBjrHUa4AAAAA:DCjk_WMWZ5Is6KvGpmS8a2bL9LskvV0P1zEG4U2u-Tm_C8sixu1w65OpTyjml1HEpaikXhtYsg",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Reachability",
    "Variation": "sensitive incremental #SSR",
    "Alias": "",
    "Parents": "#SSR",
    "Children": "",
    "Problem Description": "A data structure with sensitivity $d$ for a problem $P$ has the following properties: It obtains an instance $p$ of $P$ and is allowed polynomial preprocessing time on $p$. After the preprocessing, the data structure must provide the following operations:\n\n(Batch) Update: Up to $d$ changes are performed to the initial problem instance $p$, e.g., $d$ edges are added to or removed from $p$.\n\nQuery: The user queries a specific property about the instance of the problem after the last update, e.g., the shortest path between two nodes avoiding the edges deleted in the last update.\n\nIn the incremental version of these problems, the batch update adds edges to $p$.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$d$: sensitivity",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Reachability",
    "Variation": "ST-Reach",
    "Alias": "",
    "Parents": "",
    "Children": "constant sensitivity incremental ST-Reach; 1-sensitive incremental ss-reach; 2-sensitive incremental st-reach; ap-reach;",
    "Problem Description": "Given a graph $G=(V,E)$, determine whether each node $s\\in S\\subseteq V$ can reach a node $t\\in T \\subseteq V$.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Reachability",
    "Variation": "Directed st-Reach",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a directed graph $G=(V,E)$ and vertices $s, t \\in V$, determine wheteher $t$ is reachable from $s$.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Reachability",
    "Variation": "constant sensitivity incremental ST-Reach",
    "Alias": "",
    "Parents": "ST-Reach",
    "Children": "",
    "Problem Description": "Given a graph $G=(V,E)$, incrementally determine whether each node $s\\in S\\subseteq V$ can reach a node $t\\in T \\subseteq V$, with a constant sensitivity of $K(\\epsilon, t)$, i.e. when $K(\\epsilon, t)$ edges are added.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Reachability",
    "Variation": "1-sensitive incremental ss-reach",
    "Alias": "",
    "Parents": "st-Reach",
    "Children": "",
    "Problem Description": "Given a directed graph $G=(V,E)$ and a source node $s \\in G$, an incremental single-source reachability algorithm maintains the set of nodes reachable from $s$ (i.e., all nodes $v$ for which there is a path from $s$ to $v$ in the current version of $G$) during a sequence of edge insertions, with sensitivity 1, i.e. when 1 edge is inserted.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Reachability",
    "Variation": "2-sensitive incremental st-reach",
    "Alias": "",
    "Parents": "st-Reach",
    "Children": "",
    "Problem Description": "Given a directed graph $G=(V,E)$ and vertices $s, t \\in V$, incrementally determine wheteher $t$ is reachable from $s$, with sensitivity 2, i.e. when 2 edges are added.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Vertex Reachability",
    "Variation": "ap-reach",
    "Alias": "",
    "Parents": "st-Reach",
    "Children": "",
    "Problem Description": "Given a directed graph $G=(V,E)$, determine for each pair $s \\neq t \\in V$ whether $t$ is reachable from $s$.",
    "Description Reference": "https://arxiv.org/pdf/1703.01638.pdf",
    "Parameters": "$n$: number of vertices\n$m$: number of edges",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "RNA Folding",
    "Variation": "RNA Folding",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "In RNA Folding we are given a string over some alphabet (e.g. $\\{A, C, G, T\\}$) with a fixed pairing between its symbols (e.g. $A − T$ match and $C − G$ match), and the goal is to compute the maximum number of non-crossing arcs between matching letters that one can draw above the string (which corresponds to the minimum energy folding in two dimensions).",
    "Description Reference": "https://ieeexplore.ieee.org/iel7/8100284/8104011/08104058.pdf?casa_token=tuNJo01Tyh0AAAAA:VuzSKuC4fDZ_f7O99-O062M2xCFl8qZqUr1BjNKgzWI6rp9Ij6-NXHZvpi16JN_jEucLmPI",
    "Parameters": "$n$: length of the given string",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Bioinformatics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Maximum Inner Product Search",
    "Variation": "Maximum Inner Product Search",
    "Alias": "MIPS",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a new query $q$, MIPS targets at retrieving the datum having the largest inner product with $q$ from the database $A$. Formally, the MIPS problem is formulated as below:\n\n$p = \\arg \\max \\limits_{a \\in A} a \\top q$",
    "Description Reference": "https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Shen_Learning_Binary_Codes_ICCV_2015_paper.pdf",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Reachability in MDPs",
    "Alias": "",
    "Parents": "",
    "Children": "Disjunctive Reachability Queries in MDPs; Conjunctive Reachability Queries in MDPs;",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a Markov Decision Process (MDP), and the objective is reachability: given a set of target vertices $T\\subseteq V$, determine whether there is an infinite path that visits a vertex in $T$ at least once (i.e. you want to reach some vertex in $T$).",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Disjunctive Reachability Queries in MDPs",
    "Alias": "",
    "Parents": "Reachability in MDPs",
    "Children": "",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a Markov Decision Process (MDP), and the objective is reachability: given a set of target vertices $T\\subseteq V$, determine whether there is an infinite path that visits a vertex in $T$ at least once (i.e. you want to reach some vertex in $T$).\n\nFurthermore, given $k$ reachability objectives, the disjunctive reachability query question asks whether there is a strategy for player 1 to ensure that one of the reachability objectives is satisfied with probability 1.\n\nDisjunctive queries do not coincide with disjunctive objectives on MDPs.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Conjunctive Reachability Queries in MDPs",
    "Alias": "Generalized Reachability in MDPs",
    "Parents": "Reachability in MDPs",
    "Children": "",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a Markov Decision Process (MDP), and the objective is reachability: given a set of target vertices $T\\subseteq V$, determine whether there is an infinite path that visits a vertex in $T$ at least once (i.e. you want to reach some vertex in $T$).\n\nFurthermore, given $k$ reachability objectives, the conjunctive reachability query question asks whether there is a strategy for player 1 to ensure that all the reachability objectives are satisfied with probability 1.\n\nConjunctive queries coincide with conjunctive objectives on graphs and MDPs.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Safety in MDPs",
    "Alias": "",
    "Parents": "Safety in Graphs",
    "Children": "Disjunctive Safety Queries in MDPs; Conjunctive Safety Queries in MDPs;",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a Markov Decision Process (MDP), and the objective is safety: given a set of target vertices $T\\subseteq V$, determine whether there is an infinite path that does not visit any vertex in $T$ (i.e. you want to avoid all vertices in $T$).",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Disjunctive Safety Queries in MDPs",
    "Alias": "",
    "Parents": "Safety in MDPs",
    "Children": "",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a Markov Decision Process (MDP), and the objective is safety: given a set of target vertices $T\\subseteq V$, determine whether there is an infinite path that does not visit any vertex in $T$ (i.e. you want to avoid all vertices in $T$).\n\nFurthermore, given $k$ safety objectives, the disjunctive safety query question asks whether there is a strategy for player 1 to ensure that one of the safety objectives is satisfied with probability 1.\n\nDisjunctive queries do not coincide with disjunctive objectives on MDPs.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Conjunctive Safety Queries in MDPs",
    "Alias": "",
    "Parents": "Safety in MDPs",
    "Children": "",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a Markov Decision Process (MDP), and the objective is safety: given a set of target vertices $T\\subseteq V$, determine whether there is an infinite path that does not visit any vertex in $T$ (i.e. you want to avoid all vertices in $T$).\n\nFurthermore, given $k$ safety objectives, the conjunctive safety query question asks whether there is a strategy for player 1 to ensure that all the safety objectives are satisfied with probability 1.\n\nConjunctive queries coincide with conjunctive objectives on graphs and MDPs.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Safety in Graphs",
    "Alias": "",
    "Parents": "",
    "Children": "Safety in MDPs; Disjunctive Queries of Safety in Graphs;",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a standard graph, and the objective is safety: given a set of target vertices $T\\subseteq V$, determine whether or not there is a path that does not visit any vertex in $T$ (i.e. you want to avoid all vertices in $T$).",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Disjunctive Queries of Safety in Graphs",
    "Alias": "",
    "Parents": "Safety in Graphs",
    "Children": "",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a standard graph, and the objective is safety: given a set of target vertices $T\\subseteq V$, determine whether or not there is a path that does not visit any vertex in $T$ (i.e. you want to avoid all vertices in $T$).\n\nFurthermore, in the disjunctive queries problem, you are given multiple safety objectives (i.e. multiple target sets $T_i$) and you are to determine whether or not there is a path where at least one of the safety objectives is satisfied (i.e. whether or not an infinite path avoids all vertices in at least one of the target sets).\n\nDisjunctive queries coincide with disjunctive objectives on graphs.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Disjunctive coBüchi Objectives",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a standard graph, and the objective is coBüchi: given a set of target vertices $T\\subseteq V$, determine whether or not there is a path that visits the set $T$ a finite amount of times.\n\nFurthermore, in the disjunctive problem, you are given multiple coBüchi objectives (i.e. multiple target sets $T_i$) and you are to determine whether or not there is a path where at least one of the coBüchi objectives is satisfied (i.e. whether or not an infinite path visits any target set $T_i$ a finite amount of times).",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Model-Checking Problem",
    "Variation": "Generalized Büchi Games",
    "Alias": "Conjunctive Büchi Objectives",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given a model of a system and an objective, the model-checking problem asks whether the model satisfies the objective.\n\nIn this case, the model is a standard graph, and the objective is Büchi: given a set of target vertices $T\\subseteq V$, determine whether or not there is a path that visits the set $T$ an infinite amount of times.\n\nFurthermore, in the conjunctive problem, you are given multiple Büchi objectives (i.e. multiple target sets $T_i$) and you are to determine whether or not there is a path where all of the Büchi objectives are satisfied (i.e. whether or not an infinite path visits all target sets $T_i$ an infinite amount of times).",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/2933575.2935304",
    "Parameters": "$n$: number of vertices\n$m$: number of edges\n$MEC$: O(\\min(n^2, m^{1.5}))",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Dihedral Rotation Queries",
    "Variation": "Static Dihedral Rotation Queries",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Determine whether a given dihedral rotation is feasible or not, without modifying the chain.",
    "Description Reference": "https://doi.org/10.1016/S0925-7721(02)00156-6",
    "Parameters": "$n$: number of edges in the chain",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "preprocessing: $\\Omega(n^2)$\nor\nquery: $\\Omega(n)$",
    "Lower Bound Reference": "https://doi.org/10.1016/S0925-7721(02)00156-6",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Dihedral Rotation Queries",
    "Variation": "Dynamic Dihedral Rotation Queries",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "Determine whether a given dihedral rotation is feasible or not, and if it is, modify the chain by performing the rotation.",
    "Description Reference": "https://doi.org/10.1016/S0925-7721(02)00156-6",
    "Parameters": "$n$: number of edges in the chain",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "preprocessing: $\\Omega(n^2)$\nquery: $\\Omega(n)$",
    "Lower Bound Reference": "https://doi.org/10.1016/S0925-7721(02)00156-6",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Bichromatic Hamming Close Pair",
    "Variation": "Bichromatic Hamming Close Pair",
    "Alias": "BHCP",
    "Parents": "",
    "Children": "",
    "Problem Description": "Given two sets $A = \\{a_1, \\ldots, a_n\\} \\subseteq \\{0, 1\\}^d$ and $B = \\{b_1, \\ldots, b_n\\} \\subseteq \\{0, 1\\}^d$ of $n$ binary vectors and an integer $t \\in \\{2, \\ldots, d\\}$, decide if there exists a pair $a \\in A$ and $b \\in B$ such that the number of coordinates in which they differ is less than $t$ (formally, $Hamming(a, b) := ||a − b||1 < t$). If there is such a pair $(a, b)$, we call it a close pair.",
    "Description Reference": "https://proceedings.neurips.cc/paper/2017/file/635440afdfc39fe37995fed127d7df4f-Paper.pdf",
    "Parameters": "$n$: number of binary vectors in each set\n$d$: dimensionality of vectors\n$t$: max Hamming distance",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "Support Vector Machines (SVM)",
    "Variation": "Approximate Hard-Margin SVM",
    "Alias": "",
    "Parents": "",
    "Children": "",
    "Problem Description": "A (primal) hard-margin SVM is an optimization problem of the following form: \n\n$\\min\\limits_{\\alpha_1,\\ldots,\\alpha_n\\geq 0} \\frac{1}{2} \\sum \\limits_{i,j = 1}^n \\alpha_i \\alpha_j y_i y_j k(x_i, x_j)$\n\nsubject to $y_i f(x_i) \\geq 1, i = 1, \\ldots, n$\nwhere $f(x) := \\sum_{i=1}^n \\alpha_i y_i k(x_i, x)$",
    "Description Reference": "https://proceedings.neurips.cc/paper/2017/file/635440afdfc39fe37995fed127d7df4f-Paper.pdf",
    "Parameters": "",
    "Parameter for graphs": "",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "3SUM",
    "Variation": "3SUM",
    "Alias": "",
    "Parents": "Real 3SUM",
    "Children": "3SUM'; All-Integers 3SUM;",
    "Problem Description": "Given a set $S$ of integers, determine whether there is a subset of $S$ of size 3 that sums to 0.",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$S$: the set of integers\n$n$: the number of integers in the set",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^2/max(w/(log w)^2, (log n)^2/(log log n)^2))",
    "Upper Bound Reference": "https://link.springer.com/article/10.1007/s00453-007-9036-3",
    "Best Known Lower Bound": "\\Omega(n^{2-\\epsilon})",
    "Lower Bound Reference": "3SUM Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "3SUM",
    "Variation": "Real 3SUM",
    "Alias": "",
    "Parents": "",
    "Children": "3SUM;",
    "Problem Description": "Given a set $S$ of reals, determine whether there is a subset of $S$ of size 3 that sums to 0.",
    "Description Reference": "https://dl.acm.org/doi/abs/10.1145/3363541",
    "Parameters": "$S$: the set of reals\n$n$: the number of real numbers in the set",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "O(n^2*(log log n)^{O(1)}/(log n)^2)",
    "Upper Bound Reference": "https://dl.acm.org/doi/abs/10.1145/3363541",
    "Best Known Lower Bound": "\\Omega(n^{2-\\epsilon})",
    "Lower Bound Reference": "3SUM Hypothesis",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "3SUM",
    "Variation": "3SUM'",
    "Alias": "",
    "Parents": "3SUM",
    "Children": "",
    "Problem Description": "Given three sets of integers $A, B, C$ of total size $n$, are there $a\\in A, b\\in B, c\\in C$ such that $a + b = c$?",
    "Description Reference": "https://doi.org/10.1016/0925-7721(95)00022-2",
    "Parameters": "$n$: number of integers in each set",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  },
  {
    "Old Family #": "",
    "Family Name": "3SUM",
    "Variation": "All-Integers 3SUM",
    "Alias": "",
    "Parents": "3SUM",
    "Children": "",
    "Problem Description": "Given three lists $A, B, C$ of $n$ integers each, output the list of all integers $a \\in A$ such that there exist $b \\in B,c \\in C$ with $a + b + c = 0$.",
    "Description Reference": "https://dl.acm.org/doi/pdf/10.1145/3186893",
    "Parameters": "$n$: number of integers in each set",
    "Parameter for graphs": "n",
    "Input Size": "",
    "Output Size": "",
    "Best Known Upper Bound": "",
    "Upper Bound Reference": "",
    "Best Known Lower Bound": "",
    "Lower Bound Reference": "",
    "Domain": "Combinatorics",
    "": "",
    "__1": "",
    "__2": "",
    "__3": ""
  }
]